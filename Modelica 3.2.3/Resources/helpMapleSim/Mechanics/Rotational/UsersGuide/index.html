<html><head><title>Modelica.Mechanics.Rotational.UsersGuide</title></head>
<style>
body { font-family: Droid Serif,serif; font-size: 16px; line-height: 24px;  }
p, dt, pre, blockquote, ol, ul, table, hr { margin-top: 24px; margin-bottom: 0 }
img { margin-top: 24px }
img.icon, embed.icon { float: right; margin: 0 0 24px 24px; border: 0 }
h1, h2, h3, h4, h5, th { font-family: Droid Sans,sans-serif }
h1 { font-size: 26px; line-height: 26px; margin: 18px 0 0 0 }h2 { font-size: 21px; line-height: 24px; margin: 26px 0 -2px 0 }h3 { font-size: 18px; line-height: 24px; margin: 27px 0 -3px 0 }h4 { font-size: 16px; line-height: 24px; margin: 28px 0 -4px 0; font-style: italic }h1 .subtitle, h2 .subtitle { font-size: 16px; font-style: italic }
h1 br, h2 br { margin-bottom: 10px }
p.interface { background-color: #EEE; padding: 20px; border: 1px solid #CCE; border-radius: 14px }
code, pre, p.interface { font-family: Droid Sans Mono,monospace; font-size: 14px; line-height: 20px }
li, dd, li p, dd p, li dt, dd dt, li pre, dd pre, li blockquote, dd blockquote, li table, dd table { margin-top: 11px; margin-bottom: 11px }
dt + dt, dd, ul ul { margin-top: 0 }
blockquote pre, blockquote blockquote { margin-top: 0; margin-bottom: 0 }
ul ul li { margin-top:5px; margin-bottom:6px }
td, th { vertical-align: top; font-size: 14px; line-height: 20px }
th { background-color: #EEE }
td p, th p { margin-top: 10px }
td code, th code { font-size: 13px }
hr { border: 0; border-bottom: 1px dotted darkred; clear: right }
</style>
<body>
<a name="UsersGuide"><h1><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Package <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;UsersGuide<br><span class="subtitle">User's Guide of Rotational Library</span></h1></a>
<h3>Information</h3>
<p>

<p>
Library <strong>Rotational</strong> is a <strong>free</strong> Modelica package providing
1-dimensional, rotational mechanical components to model in a convenient way
drive trains with frictional losses. More details are given in the following
sub-sections:
</p>

<ul>
<li> <a href="index.html#Overview">Overview</a></li>
<li> <a href="index.html#FlangeConnectors">Flange Connectors</a></li>
<li> <a href="index.html#SupportTorques">Support Torques</a></li>
<li> <a href="index.html#SignConventions">Sign Conventions</a></li>
<li> <a href="index.html#UserDefinedComponents">User Defined Components</a></li>
<li> <a href="index.html#RequirementsForSimulationTool">Requirements for Simulation Tools</a></li>
<li> <a href="index.html#StateSelection">State Selection</a></li>
<li> <a href="index.html#ModelingOfFriction">Modeling of Friction</a></li>
</ul>

<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<h3>Package Contents</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Name</th><th>Description</th></tr><tr><td><a href="#Contact"><code>Contact</code></a></td><td>Contact</td></tr>
<tr><td><a href="#FlangeConnectors"><code>FlangeConnectors</code></a></td><td>Flange Connectors</td></tr>
<tr><td><a href="#ModelingOfFriction"><code>ModelingOfFriction</code></a></td><td>Modeling of Friction</td></tr>
<tr><td><a href="#Overview"><code>Overview</code></a></td><td>Overview</td></tr>
<tr><td><a href="#RequirementsForSimulationTool"><code>RequirementsForSimulationTool</code></a></td><td>Requirements for Simulation Tools</td></tr>
<tr><td><a href="#SignConventions"><code>SignConventions</code></a></td><td>Sign Conventions</td></tr>
<tr><td><a href="#StateSelection"><code>StateSelection</code></a></td><td>State Selection</td></tr>
<tr><td><a href="#SupportTorques"><code>SupportTorques</code></a></td><td>Support Torques</td></tr>
<tr><td><a href="#UserDefinedComponents"><code>UserDefinedComponents</code></a></td><td>User Defined Components</td></tr>
</table>
<hr><a name="Overview"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;Overview<br><span class="subtitle">Overview</span></h2></a>
<h3>Information</h3>
<p>


<p>
This package contains components to model <strong>1-dimensional rotational
mechanical</strong> systems, including different types of gearboxes,
shafts with inertia, external torques, spring/damper elements,
frictional elements, backlash, elements to measure angle, angular velocity,
angular acceleration and the cut-torque of a flange. In sublibrary
<strong>Examples</strong> several examples are present to demonstrate the usage of
the elements. Just open the corresponding example model and simulate
the model according to the provided description.
</p>
<p>
A unique feature of this library is the <strong>component-oriented</strong>
modeling of <strong>Coulomb friction</strong> elements, such as friction in bearings,
clutches, brakes, and gear efficiency. Even (dynamically) coupled
friction elements, e.g., as in automatic gearboxes, can be handled
<strong>without</strong> introducing stiffness which leads to fast simulations.
The underlying theory is new and is based on the solution of mixed
continuous/discrete systems of equations, i.e., equations where the
<strong>unknowns</strong> are of type <strong>Real</strong>, <strong>Integer</strong> or <strong>Boolean</strong>.
Provided appropriate numerical algorithms for the solution of such types of
systems are available in the simulation tool, the simulation of
(dynamically) coupled friction elements of this library is
<strong>efficient</strong> and <strong>reliable</strong>.
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/drive1.png" alt="drive1">
</p>

<p>
A simple example of the usage of this library is given in the
figure above. This drive consists of a shaft with inertia J1=0.2 which
is connected via an ideal gearbox with gear ratio=5 to a second shaft
with inertia J2=5. The left shaft is driven via an external,
sinusoidal torque.
The <strong>filled</strong> and <strong>non-filled grey squares</strong> at the left and
right side of a component represent <strong>mechanical flanges</strong>.
Drawing a line between such squares means that the corresponding
flanges are <strong>rigidly attached</strong> to each other.
By convention in this library, the connector characterized as a
<strong>filled</strong> grey square is called <strong>flange_a</strong> and placed at the
left side of the component in the "design view" and the connector
characterized as a <strong>non-filled</strong> grey square is called <strong>flange_b</strong>
and placed at the right side of the component in the "design view".
The two connectors are completely <strong>identical</strong>, with the only
exception that the graphical layout is a little bit different in order
to distinguish them for easier access of the connector variables.
For example, <code>J1.flange_a.tau</code> is the cut-torque in the connector
<code>flange_a</code> of component <code>J1</code>.
</p>
<p>
The components of this
library can be <strong>connected</strong> together in an <strong>arbitrary</strong> way. E.g., it is
possible to connect two springs or two shafts with inertia directly
together, see figure below.
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/driveConnections1.png" alt="driveConnections1"><br>
<img src="../../../../Images/Mechanics/Rotational/driveConnections2.png" alt="driveConnections2">
</p>

<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="FlangeConnectors"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;FlangeConnectors<br><span class="subtitle">Flange Connectors</span></h2></a>
<h3>Information</h3>
<p>

<p>
A flange is described by the connector class
Interfaces.<strong>Flange_a</strong>
or Interfaces.<strong>Flange_b</strong>. As already noted, the two connector
classes are completely identical. There is only a difference in the icons,
in order to easier identify a flange variable in a diagram.
Both connector classes contain the following variables:
</p>
<pre>
   Modelica.SIunits.Angle       phi  "Absolute rotation angle of flange";
   <strong>flow</strong> Modelica.SIunits.Torque tau  "Cut-torque in the flange";
</pre>
<p>
If needed, the angular velocity <code>w</code> and the
angular acceleration <code>a</code> of a flange connector can be
determined by differentiation of the flange angle <code>phi</code>:
</p>
<pre>
     w = <strong>der</strong>(phi);    a = <strong>der</strong>(w);
</pre>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="SupportTorques"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;SupportTorques<br><span class="subtitle">Support Torques</span></h2></a>
<h3>Information</h3>
<p>


<p>The following figure shows examples of components equipped with
a support flange (framed flange in the lower center), which can be used
to fix components on the ground or on other rotating elements or to combine
them with force elements. Via Boolean parameter <strong>useSupport</strong>, the
support torque is enabled or disabled. If it is enabled, it must be connected.
If it is disabled, it need not be connected.
Enabled support flanges offer, e.g., the possibility to model gearboxes mounted on
the ground via spring-damper-systems (cf. example
<a href="../Examples/index.html#ElasticBearing">ElasticBearing</a>).
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/bearing.png" alt="bearing">
</p>

<p>
Depending on the setting of <strong>useSupport</strong>, the icon of the corresponding
component is changing, to either show the support flange or a ground mounting.
For example, the two implementations in the following figure give
identical results.
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/bearing2.png" alt="bearing2">
</p>

<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="SignConventions"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;SignConventions<br><span class="subtitle">Sign Conventions</span></h2></a>
<h3>Information</h3>
<p>


<p>
The variables of a component of this library can be accessed in the
usual way. However, since most of these variables are basically elements
of <strong>vectors</strong>, i.e., have a direction, the question arises how the
signs of variables shall be interpreted. The basic idea is explained
at hand of the following figure:
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/drive2.png" alt="drive2">
</p>

<p>
In the figure, three identical drive trains are shown. The only
difference is that the gear of the middle drive train and the
gear as well as the right inertia of the lower drive train
are horizontally flipped with regards to the upper drive train.
The signs of variables are now interpreted in the following way:
Due to the 1-dimensional nature of the model, all components are
basically connected together along one line (more complicated
cases are discussed below). First, one has to define
a <strong>positive</strong> direction of this line, called <strong>axis of rotation</strong>.
In the top part of the figure this is characterized by an arrow
defined as <code>axis of rotation</code>. The simple rule is now:
If a variable of a component is positive and can be interpreted as
the element of a vector (e.g., torque or angular velocity vector), the
corresponding vector is directed into the positive direction
of the axis of rotation. In the following figure, the right-most
inertias of the figure above are displayed with the positive
vector direction displayed according to this rule:
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/drive3.png" alt="drive3">
</p>
<p>
The cut-torques <code>J2.flange_a.tau, J4.flange_a.tau, J6.flange_b.tau</code>
of the right inertias are all identical and are directed into the
direction of rotation if the values are positive. Similarly,
the angular velocities <code>J2.w, J4.w, J6.w</code> of the right inertias
are all identical and are also directed into the
direction of rotation if the values are positive. Some special
cases are shown in the next figure:
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/drive4.png" alt="drive4">
</p>

<p>
In the upper part of the figure, two variants of the connection of an
external torque and an inertia are shown. In both cases, a positive
signal input into the torque component accelerates the inertias
<code>inertia1, inertia2</code> into the positive axis of rotation,
i.e., the angular accelerations <code>inertia1.a, inertia2.a</code>
are positive and are directed along the "axis of rotation" arrow.
In the lower part of the figure the connection of inertias with
a planetary gear is shown. Note, that the three flanges of the
planetary gearbox are located along the axis of rotation and that
the axis direction determines the positive rotation along these
flanges. As a result, the positive rotation for <code>inertia4, inertia6</code>
is as indicated with the additional grey arrows.
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="UserDefinedComponents"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;UserDefinedComponents<br><span class="subtitle">User Defined Components</span></h2></a>
<h3>Information</h3>
<p>

<p>
In this section some hints are given to define your own
1-dimensional rotational components which are compatible with the
elements of this package.
It is convenient to define a new
component by inheritance from one of the following base classes,
which are defined in sublibrary Interfaces:
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Name</th><th>Description</th></tr>
<tr>
  <td><a href="../Interfaces/index.html#PartialCompliant">PartialCompliant</a>
  </td>
  <td>Compliant connection of two rotational 1-dim. flanges
                   (used for force laws such as a spring or a damper).</td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialCompliantWithRelativeStates">PartialCompliantWithRelativeStates</a>
  </td>
  <td> Same as "PartialCompliant", but relative angle and relative speed are
                    defined as preferred states. Use this partial model if the force law
                    needs anyway the relative speed. The advantage is that it is usually better
                    to use relative angles between drive train components
                    as states, especially, if the angle is not limited (e.g., as for drive trains
                    in vehicles).
</td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialElementaryTwoFlangesAndSupport2">PartialElementaryTwoFlangesAndSupport2</a>
</td>
  <td> Partial model for a 1-dim. rotational gear consisting of the flange of
                    an input shaft, the flange of an output shaft and the support.
  </td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialTorque">PartialTorque</a>
</td>
  <td> Partial model of a torque acting at the flange (accelerates the flange).
  </td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialTwoFlanges">PartialTwoFlanges</a>
</td>
  <td>General connection of two rotational 1-dim. flanges.
  </td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialAbsoluteSensor">PartialAbsoluteSensor</a>
</td>
  <td>Measure absolute flange variables.
  </td>
</tr>

<tr>
  <td><a href="../Interfaces/index.html#PartialRelativeSensor">PartialRelativeSensor</a>
</td>
  <td>Measure relative flange variables.
  </td>
</tr>
</table>

<p>
The difference between these base classes are the auxiliary
variables defined in the model and the relations between
the flange variables already defined in the base class.
For example, in model <strong>PartialCompliant</strong> there is no
support flange, whereas in model
<strong>PartialElementaryTwoFlangesAndSupport2</strong>
there is a support flange.
</p>
<p>
The equations of a mechanical component are vector equations, i.e.,
they need to be expressed in a common coordinate system.
Therefore, for a component a <strong>local axis of rotation</strong> has to be
defined. All vector quantities, such as cut-torques or angular
velocities have to be expressed according to this definition.
Examples for such a definition are given in the following figure
for an inertia component and a planetary gearbox:
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/driveAxis.png" alt="driveAxis">
</p>

<p>
As can be seen, all vectors are directed into the direction
of the rotation axis. The angles in the flanges are defined
correspondingly. For example, the angle <code>sun.phi</code> in the
flange of the sun wheel of the planetary gearbox is positive,
if rotated in mathematical positive direction (= counter clock
wise) along the axis of rotation.
</p>
<p>
On first view, one may assume that the selected local
coordinate system has an influence on the usage of the
component. But this is not the case, as shown in the next figure:
</p>

<p>
<img src="../../../../Images/Mechanics/Rotational/inertias.png" alt="inertias">
</p>

<p>
In the figure the <strong>local</strong> axes of rotation of the components
are shown. The connection of two inertias in the left and in the
right part of the figure are completely equivalent, i.e., the right
part is just a different drawing of the left part. This is due to the
fact, that by a connection, the two local coordinate systems are
made identical and the (automatically) generated connection equations
(= angles are identical, cut-torques sum-up to zero) are also
expressed in this common coordinate system. Therefore, even if in
the left figure it seems to be that the angular velocity vector of
<code>J2</code> goes from right to left, in reality it goes from
left to right as shown in the right part of the figure, where the
local coordinate systems are drawn such that they are aligned.
Note, that the simple rule stated in section 4 (Sign conventions)
also determines that
the angular velocity of <code>J2</code> in the left part of the
figure is directed from left to right.
</p>
<p>
To summarize, the local coordinate system selected for a component
is just necessary, in order that the equations of this component
are expressed correctly. The selection of the coordinate system
is arbitrary and has no influence on the usage of the component.
Especially, the actual direction of, e.g., a cut-torque is most
easily determined by the rule of section 4. A more strict determination
by aligning coordinate systems and then using the vector direction
of the local coordinate systems, often requires a re-drawing of the
diagram and is therefore less convenient to use.
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="RequirementsForSimulationTool"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;RequirementsForSimulationTool<br><span class="subtitle">Requirements for Simulation Tools</span></h2></a>
<h3>Information</h3>
<p>


<p>
This library is designed in a fully object oriented way in order that
components can be connected together in every meaningful combination
(e.g., direct connection of two springs or two inertias).
As a consequence, most models lead to a system of
differential-algebraic equations of <strong>index 3</strong> (= constraint
equations have to be differentiated twice in order to arrive at
a state space representation) and the Modelica translator or
the simulator has to cope with this system representation.
According to our present knowledge, this requires that the
Modelica translator is able to symbolically differentiate equations
(otherwise it is e.g., not possible to provide consistent initial
conditions; even if consistent initial conditions are present, most
numerical DAE integrators can cope at most with index 2 DAEs).
</p>
<p>
The elements of this library can be connected together in an
arbitrary way. However, difficulties may occur, if the elements which can <strong>lock</strong> the
<strong>relative motion</strong> between two flanges are connected <strong>rigidly</strong>
together such that essentially the <strong>same relative motion</strong> can be locked.
The reason is
that the cut-torque in the locked phase is not uniquely defined if the
elements are locked at the same time instant (i.e., there does not exist a
unique solution) and some simulation systems may not be
able to handle this situation, since this leads to a singularity during
simulation. Currently, this type of problem can occur with the
Coulomb friction elements <strong>BearingFriction, Clutch, Brake, LossyGear</strong> when
the elements become stuck:
</p>
<p>
<img src="../../../../Images/Mechanics/Rotational/driveConnections3.png" alt="driveConnections3">
</p>
<p>
In the figure above two typical situations are shown: In the upper part of
the figure, the series connection of rigidly attached BearingFriction and
Clutch components are shown. This does not hurt, because the BearingFriction
element can lock the relative motion between the element and the housing,
whereas the clutch element can lock the relative motion between the two
connected flanges. Contrary, the drive train in the lower part of the figure
may give rise to simulation problems, because the BearingFriction element
and the Brake element can lock the relative motion between a flange and
the housing and these flanges are rigidly connected together, i.e.,
essentially the same relative motion can be locked. These difficulties
may be solved by either introducing a compliance between these flanges
or by combining the BearingFriction and Brake element into
one component and resolving the ambiguity of the frictional torque in the
stuck mode. A tool may handle this situation also <strong>automatically</strong>,
by picking one solution of the infinitely many, e.g., the one where
the difference to the value of the previous time instant is as small
as possible.
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="StateSelection"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;StateSelection<br><span class="subtitle">State Selection</span></h2></a>
<h3>Information</h3>
<p>

<p>
Only a few components of the Rotational library use the der(..) operator
and are therefore candidates to have states. Most important, component <a href="../Components/index.html#Inertia">Inertia</a>
defines the absolute rotation angle and the absolute angular velocity of this
component as candidate for states. In the "Advanced" menu the built-in StateSelect
enumeration can be set to define the priority to use these variables as states.
Without further action, in most cases a tool will select these variables as states.
</p>

<p>
For positioning drive trains where the goal is to position a load (e.g. the drive
train of a robot, or of an elevator), the absolute angles of the components are bounded,
and the issue discussed below is not present.
</p>

<p>
For drive trains where the goal is to control the velocity of a load (e.g. the drive
train of a vehicle or the crank angle of an engine),
the absolute angles of the components are quickly increasing
during operation. This is critical, because then the step size control of time
integrators might then no longer work appropriately:
</p>

<p>
Integrators with step size control adjust their time step size automatically
to meet user defined error bounds ("tolerances").
Typically the local error estimate EST_i is compared with a mixed bound for absolute and relative errors.
</p>

<pre>
   EST_i &le; abstol_i + reltol_i*|x_i|
</pre>

<p>
Here, abstol_i and reltol_i denote the bounds for the absolute and relative error of state variable x_i, respectively. This mixed error bound is used since it is more robust than a pure relative error based error bound if the nominal value x_i  is (very) close to 0.
In a Modelica simulation model, typically the same relative tolerance reltol is used for all
states and the absolute tolerances are computed using the relative tolerance and the
nominal values of the states:
</p>

<pre>
   reltol_i = reltol
   abstol_i = reltol*x_i(nominal)*0.01
</pre>

<p>
This error control fails if the state variable x_i grows without bounds (such as for a
drive train or the crank angle of a vehicle), since then the allowed error
also grows without bounds. The effect is that the error control on this variable is practically
switched off. The correct way to handle this would be to set reltol_i = 0 on such a state
variable and only use an absolute tolerance for the step size control.
</p>

<p>
Currently, in Modelica there is no possibility to provide this information.
In order to reduce this effect, it is advisable to not use absolute angles, but
relative angles as states. A user can define relative variables as states
explicitly with component
<a href="../Components/index.html#RelativeStates">RelativeStates</a>.
Furthermore, all compliant components, such as
<a href="../Components/index.html#SpringDamper">SpringDamper</a> are
defining the relative angle and the relative angular velocity as preferred states.
Therefore, a tool will select in most cases relative angles as states.
</p>

<p>
The relative angles of compliant components are usually small. For example, the
deformation of a typical elastic component is in the order of 1e-4 rad.
Without further action, the error control would not work properly on variables
that are so small (so often switching the error control off). The remedy is to define
explicitly a nominal value on the relative angle. This definition is provided in the
"Advanced" menu of the compliant components with parameter "phi_nominal".
The default value is 1e-4 rad, to be in the order of a compliant deformation of a
drive. For some components, like
a <a href="../Components/index.html#Clutch">Clutch</a>
this might be too small and a value of phi_nominal=1 might be more appropriate
(a value of phi_nominal = 1e-4 does not hurt, but just makes the error control
unnecessarily stringent).
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="ModelingOfFriction"><h2><embed class="icon" src="../../../images/icon0002.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;ModelingOfFriction<br><span class="subtitle">Modeling of Friction</span></h2></a>
<h3>Information</h3>
<p>

<p>
Several elements of this library model <strong>Coulomb friction</strong> with the method proposed in:
</p>

<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):</dt>
<dd><strong>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</dd>
</dl>

<p>
The friction equations are defined in base model
<a href="../Interfaces/index.html#PartialFriction">Interfaces.PartialFriction</a>.
Here are some explanations:
</p>

<p>
Assume first the most simplest friction problem: A block sliding on a surface.
The friction force "f" acts between the block surface and the environment surface and shall be a
linear function of the relative velocity "v" between the two surfaces.
When the relative velocity becomes zero, the two surfaces are stuck to each other and the friction force is no longer
a function of "v". The element starts sliding again if the friction force becomes larger than the maximum
static friction force "f0". This element could be defined with a parameterized curve description
leading to the following equations:
</p>

<blockquote><pre>forward  = s &gt; 1;
backward = s &lt; -1;
v = if forward then s-1 elseif backward then s+1 else 0;
f = if forward  then  f0+f1*(s-1) elseif
       backward then -f0+f1*(s+1) else f0*s;
</pre></blockquote>

<p>
This model completely describes the simplified friction element in
a declarative way. Unfortunately, currently it is not known how to transform such
an element description automatically in a form which can be simulated:
</p>

<p>
The block is described by the following equation:
</p>

<blockquote><pre>
m*der(v) = u - f
</pre></blockquote>

<p>
Note, that "m" is the mass of the block and "u(t)" is the given driving force.
If the element is in its "forward sliding" mode, that is s &ge; 1, this model is described by:
</p>

<blockquote><pre>
m*der(v) = u - f
       v = s - 1
       f = f_0 + f_1*(s-1)
</pre></blockquote>

<p>
which can be easily transformed into state space form with "v" as the state.
If the block becomes stuck, that is -1 &le; s &le; 1, the equation "v=0" becomes
active and therefore "v" can no longer be a state, that is an index
change takes place. Besides the difficulty to handle the variable state change,
there is a more serious problem:
</p>

<p>
Assume that the block is stuck and that "s" becomes greater than one. Before the event occurs, s &le; 1
and v = 0; at the event instant s &gt; 1 because this relation is the event triggering condition. The element
switches into the forward sliding mode where "v" is a state which is initialized with its last value "v=0".
Since "v" is a state, "s" is computed from "v" via "s := v+1", resulting in "s=1", that is the relation
"s &gt; 1" becomes false and the element switches back into the stuck mode. In other words, it is never possible to
switch into the forward sliding mode. Taking numerical errors into account, the situation is even worse.
</p>

<p>
The key to the solution is the observation that "v=0" in the stuck mode and when forward sliding starts, but
"der(v) &gt; 0" when sliding starts and der(v) = 0 in the stuck mode. Since the friction characteristic
at zero velocity is no functional relationship, again a parameterized curve description
with a new curve parameter "s_a" has to be used leading to the following equations (note: at zero velocity):
</p>

<blockquote><pre>
startFor  = sa &gt; 1;
startBack = sa &lt; -1;
        a = der(v);
        a = if startFor then sa-1 elseif startBack then sa+1 else 0;
        f = if startFor then f0   elseif startBack then  -f0 else f0*sa;
</pre></blockquote>

<p>
At zero velocity, these equations and the equation of the block form a mixed continuous/discrete set of
equations which has to be solved at event instants (e.g. by a fix point iteration),
When switching from sliding to stuck mode, the velocity is small or zero. Since the derivative of the constraint
equation der(v) = 0 is fulfilled in the stuck mode, the velocity remains small even if v = 0 is not explicitly
taken into account. The approach to use the acceleration der(v) = 0 as "constraint" instead of "v = 0",
is often used in multi-body software. The benefit is that the velocity "v" remains a state in all switching
configurations (there is a small, linear drift, but the friction element would have to stay stuck several days
before the drift becomes too large). Consequently, "v" is small but may have any sign when switching
from stuck to sliding mode; if the friction element starts to slide, say in the forward direction, one has
to wait until the velocity is really positive, before switching to forward mode (note, that even for
exact calculation without numerical errors a "waiting" phase is necessary, because "v=0" when sliding starts).
Since "der(v) > 0", this will occur after a small time period. This "waiting" procedure can be
described by a state machine. Collecting all the pieces together, finally results in the following equations
of a simple friction element:
</p>

<blockquote><pre>
// part of mixed system of equations
startFor  = pre(mode) == Stuck and sa &gt; 1;
startBack = pre(mode) == Stuck and sa  &lt; -1;
        a = der(v);
        a = if pre(mode) == Forward  or startFor  then  sa - 1    elseif
               pre(mode) == Backward or startBack then  sa + 1    else 0;
        f = if pre(mode) == Forward or startFor   then  f0 + f1*v elseif
               pre(mode) == Backward or startBack then -f0 + f1*v else f0*sa;

// state machine to determine configuration
mode = if (pre(mode) == Forward  or startFor)  and v&gt;0 then Forward  elseif
          (pre(mode) == Backward or startBack) and v&lt;0 then Backward else Stuck;
</pre></blockquote>

<p>
The above approach to model a simplified friction element is slightly generalized in model
<a href="../Interfaces/index.html#PartialFriction">Interfaces.PartialFriction</a>:
</p>

<ul>
<li> The sliding friction force has a nonlinear characteristic instead a linear one,
     by interpolation in a table of f(v) values.</li>
<li> There may be a jump in the friction force when going from stuck to sliding mode
     (described with parameter peak).</li>
</ul>
<p>Extends from <code><a href="../../../Icons/index.html#Information">Modelica.&#8203;Icons.&#8203;Information</a></code> (Icon for general information packages).</p>
<hr><a name="Contact"><h2><embed class="icon" src="../../../images/icon0004.svg" width="203" height="203" />
Class <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Mechanics</a>.&#8203;<a href="../index.html">Rotational</a>.&#8203;<a href="index.html">UsersGuide</a>.&#8203;Contact<br><span class="subtitle">Contact</span></h2></a>
<h3>Information</h3>
<p>

<h4>Library officers</h4>

<p>
<strong>Jakub Tobolar</strong> and <a href="http://www.robotic.dlr.de/Martin.Otter/"><strong>Martin Otter</strong></a><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany
</p>

<h4>Contributors to this library</h4>

<ul>
<li> <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a> (DLR-RM)</li>
<li> Christian Schweiger (DLR-RM, until 2006).</li>
<li> <a href="https://www.haumer.at/">Anton Haumer</a><br>
     Technical Consulting &amp; Electrical Engineering<br>
     D-93049 Regensburg, Germany<br>
     email: <a href="mailto:a.haumer@haumer.at">a.haumer@haumer.at</a></li>
</ul>
<p>Extends from <code><a href="../../../Icons/index.html#Contact">Modelica.&#8203;Icons.&#8203;Contact</a></code> (Icon for contact information).</p>
<hr style="border-color:#999" />
<p style="font-size:80%;color:#999;margin-top:12px">Generated 2018-10-03 12:39:39 EDT by <i>MapleSim</i>.</p>
</body></html>
