<html><head><title>Modelica.Math.Matrices.Utilities</title></head>
<style>
body { font-family: Droid Serif,serif; font-size: 16px; line-height: 24px;  }
p, dt, pre, blockquote, ol, ul, table, hr { margin-top: 24px; margin-bottom: 0 }
img { margin-top: 24px }
img.icon, embed.icon { float: right; margin: 0 0 24px 24px; border: 0 }
h1, h2, h3, h4, h5, th { font-family: Droid Sans,sans-serif }
h1 { font-size: 26px; line-height: 26px; margin: 18px 0 0 0 }h2 { font-size: 21px; line-height: 24px; margin: 26px 0 -2px 0 }h3 { font-size: 18px; line-height: 24px; margin: 27px 0 -3px 0 }h4 { font-size: 16px; line-height: 24px; margin: 28px 0 -4px 0; font-style: italic }h1 .subtitle, h2 .subtitle { font-size: 16px; font-style: italic }
h1 br, h2 br { margin-bottom: 10px }
p.interface { background-color: #EEE; padding: 20px; border: 1px solid #CCE; border-radius: 14px }
code, pre, p.interface { font-family: Droid Sans Mono,monospace; font-size: 14px; line-height: 20px }
li, dd, li p, dd p, li dt, dd dt, li pre, dd pre, li blockquote, dd blockquote, li table, dd table { margin-top: 11px; margin-bottom: 11px }
dt + dt, dd, ul ul { margin-top: 0 }
blockquote pre, blockquote blockquote { margin-top: 0; margin-bottom: 0 }
ul ul li { margin-top:5px; margin-bottom:6px }
td, th { vertical-align: top; font-size: 14px; line-height: 20px }
th { background-color: #EEE }
td p, th p { margin-top: 10px }
td code, th code { font-size: 13px }
hr { border: 0; border-bottom: 1px dotted darkred; clear: right }
</style>
<body>
<a name="Utilities"><h1><embed class="icon" src="../../../images/icon0009.svg" width="203" height="203" />
Package <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;Utilities<br><span class="subtitle">Utility functions that should not be directly utilized by the user</span></h1></a>
<h3>Information</h3>
<p>

<p>
This package contains utility functions that are utilized by higher level matrix functions.
These functions are usually not useful for an end-user.
</p>
<p>Extends from <code><a href="../../../Icons/UtilitiesPackage/index.html">Modelica.&#8203;Icons.&#8203;UtilitiesPackage</a></code> (Icon for utility packages).</p>
<h3>Package Contents</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Name</th><th>Description</th></tr><tr><td><a href="#continuousRiccatiIterative"><code>continuousRiccatiIterative</code></a></td><td>Newton's method with exact line search for iterative solving continuous algebraic Riccati equation</td></tr>
<tr><td><a href="#discreteRiccatiIterative"><code>discreteRiccatiIterative</code></a></td><td>Newton's method with exact line search for solving discrete algebraic Riccati equation</td></tr>
<tr><td><a href="#eigenvaluesHessenberg"><code>eigenvaluesHessenberg</code></a></td><td>Compute eigenvalues of an upper Hessenberg form matrix</td></tr>
<tr><td><a href="#findLocal_tk"><code>findLocal_tk</code></a></td><td>Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</td></tr>
<tr><td><a href="#householderReflection"><code>householderReflection</code></a></td><td>Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</td></tr>
<tr><td><a href="#householderSimilarityTransformation"><code>householderSimilarityTransformation</code></a></td><td>Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u'</td></tr>
<tr><td><a href="#reorderRSF"><code>reorderRSF</code></a></td><td>Reorders a real Schur form to clusters of stable and unstable eigenvalues</td></tr>
<tr><td><a href="#toUpperHessenberg"><code>toUpperHessenberg</code></a></td><td>Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q' * A * Q = H</td></tr>
</table>
<hr><a name="continuousRiccatiIterative"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;continuousRiccatiIterative<br><span class="subtitle">Newton's method with exact line search for iterative solving continuous algebraic Riccati equation</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<strong>continuousRiccatiIterative</strong>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<strong>continuousRiccatiIterative</strong>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving continuous algebraic Riccati equations (care). It utilizes Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means, that at each iteration <code>i</code> a Newton step <code><strong>delta</strong>_i</code>
</p>
<blockquote><pre>
  <strong>X</strong>_i+1 = <strong>X</strong>_i + <strong>delta</strong>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
    r = || <strong>X</strong>_i+1*<strong>A</strong> +<strong>A</strong>'*<strong>X</strong>_i+1 - <strong>X</strong>_i+1*<strong>G</strong>*<strong>X</strong>_i+1 + <strong>Q</strong> ||.
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
        -1
  G = <strong>B</strong>*<strong>R</strong> *<strong>B</strong>'
</pre></blockquote>
<p>

The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <strong>delta</strong>_i/<strong>X</strong>_i became smaller than eps.
</p>
<p>

With an appropriate initial value <strong>X</strong>0 a sufficiently accurate solution might be reach within a few iteration steps. Although a Lyapunov equation
of order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <a href="../index.html#continuousRiccati">Matrices.continuousRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.<br>

The algorithm is taken from [1] and [2].
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</pre>

<h4>Example</h4>
<blockquote><pre>
     A=[0.0,         1.0,         0.0,         0.0;
        0.0,        -1.890,       3.900e-01,  -5.530;
        0.0,        -3.400e-02,  -2.980,       2.430;
        3.400e-02,  -1.100e-03,  -9.900e-01,  -2.100e-01];

     B=[ 0.0,         0.0;
         3.600e-01,  -1.60;
        -9.500e-01,  -3.200e-02;
         3.000e-02,   0.0];

     R=[1, 0; 0, 1];

     Q=[2.313,       2.727,       6.880e-01,   2.300e-02;
        2.727,       4.271,       1.148,       3.230e-01;
        6.880e-01,   1.148,       3.130e-01,   1.020e-01;
        2.300e-02,   3.230e-01,   1.020e-01,   8.300e-02];

    X0=identity(4);

    (X,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0);

  //  X = [1.3239,  0.9015,  0.5466, -1.7672;
           0.9015,  0.9607,  0.4334, -1.1989;
           0.5466,  0.4334,  0.4605, -1.3633;
          -1.7672, -1.1989, -1.3633,  4.4612]
  // r =  2.48809423389491E-015

    (,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0,4);

   // r =  0.0004;

<br>
</pre></blockquote>
<h4>See also</h4>
<a href="index.html#discreteRiccatiIterative">Matrices.Utilities.discreteRiccatiIterative</a><br>
<a href="../index.html#continuousRiccati">Matrices.continuousRiccati</a>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>A[:,size(A, 1)]</code></td><td>Matrix A of Riccati equation X*A + A'*X -X*G*X +Q = 0</td></tr>
<tr><td><code>Real</code></td><td><code>B[size(A, 1),:]</code></td><td>Matrix B in G = B*inv(R)*B'</td></tr>
<tr><td><code>Real</code></td><td><code>R[size(B, 2),size(B, 2)]</code></td><td>Matrix R in G = B*inv(R)*B'</td></tr>
<tr><td><code>Real</code></td><td><code>Q[size(A, 1),size(A, 2)]</code></td><td>Matrix Q of Riccati equation X*A + A'*X -X*G*X +Q = 0</td></tr>
<tr><td><code>Real</code></td><td><code>X0[size(A, 1),size(A, 2)]</code></td><td>Initial approximate solution for X*A + A'*X -X*G*X +Q = 0</td></tr>
<tr><td><code>Integer</code></td><td><code>maxSteps</code></td><td>Maximal number of iteration steps</td></tr>
<tr><td><code>Real</code></td><td><code>eps</code></td><td>Tolerance for stop criterion</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>X[size(X0, 1),size(X0, 2)]</code></td><td>Solution X of Riccati equation X*A + A'*X -X*G*X +Q = 0</td></tr>
<tr><td><code>Real</code></td><td><code>r</code></td><td>Norm of X*A + A'*X - X*G*X + Q, zero for exact solution</td></tr>
</table>
<hr><a name="discreteRiccatiIterative"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;discreteRiccatiIterative<br><span class="subtitle">Newton's method with exact line search for solving discrete algebraic Riccati equation</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<strong>discreteRiccatiIterative</strong>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<strong>discreteRiccatiIterative</strong>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving discrete-time algebraic Riccati equations. It uses Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means, that at each iteration <code>i</code> a Newton step <code><strong>delta</strong>_i</code>
</p>
<blockquote><pre>
  <strong>X</strong>_i+1 = <strong>X</strong>_i + <strong>delta</strong>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
  r = || <strong>A</strong>'<strong>X</strong>_i+1*<strong>A</strong> - <strong>X</strong>_i+1 - <strong>A</strong>'<strong>X</strong>_i+1*<strong>G</strong>_i*<strong>X</strong>_i+1*<strong>A</strong> + <strong>Q</strong> ||
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
                       -1
  G_i = <strong>B</strong>*(<strong>R</strong> + <strong>B</strong>'*<strong>X</strong>_i*<strong>B</strong>) *<strong>B</strong>'
</pre></blockquote>
<p>

Output <code>r</code> is the norm of the residual of the last iteration.<br>
</p>
<p>
The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <strong>delta</strong>_i/<strong>X</strong>_i became smaller than eps.
</p>
<p>

With an appropriate initial value <strong>X</strong>0 a sufficiently accurate solution might be reach with a few iteration steps. Although a Lyapunov equation of
order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <a href="../index.html#discreteRiccati">Matrices.discreteRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.

The algorithm is taken from [1] and [2].
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</pre>

<h4>Example</h4>
<blockquote><pre>
     A  = [0.9970,    0.0000,    0.0000,    0.0000;
           1.0000,    0.0000,    0.0000,    0.0000;
           0.0000,    1.0000,    0.0000,    0.0000;
           0.0000,    0.0000,    1.0000,    0.0000];

     B  = [0.0150;
           0.0000;
           0.0000;
           0.0000];

     R = [0.2500];

     Q = [0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 1];

    X0=identity(4);

    (X,r) = Matrices.Utilities.discreteRiccatiIterative(A, B, R, Q, X0);

  //  X = [30.625, 0.0, 0.0, 0.0;
            0.0,   1.0, 0.0, 0.0;
            0.0,   0.0, 1.0, 0.0;
            0.0,   0.0, 0.0, 1.0];

  // r =   3.10862446895044E-015
</pre></blockquote>
<h4>See also</h4>
<a href="index.html#continuousRiccatiIterative">Matrices.Utilities.continuousRiccatiIterative</a><br>
<a href="../index.html#discreteRiccati">Matrices.discreteRiccati</a>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>A[:,size(A, 1)]</code></td><td>Matrix A of discrete Riccati equation</td></tr>
<tr><td><code>Real</code></td><td><code>B[size(A, 1),:]</code></td><td>Matrix B of discrete Riccati equation</td></tr>
<tr><td><code>Real</code></td><td><code>R[size(B, 2),size(B, 2)]</code></td><td>Matrix R of discrete Riccati equation</td></tr>
<tr><td><code>Real</code></td><td><code>Q[size(A, 1),size(A, 2)]</code></td><td>Matrix Q of discrete Riccati equation</td></tr>
<tr><td><code>Real</code></td><td><code>X0[size(A, 1),size(A, 2)]</code></td><td>Initial approximate solution discrete Riccati equation</td></tr>
<tr><td><code>Integer</code></td><td><code>maxSteps</code></td><td>Maximal number of iteration steps</td></tr>
<tr><td><code>Real</code></td><td><code>eps</code></td><td>Tolerance for stop criterion</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>X[size(X0, 1),size(X0, 2)]</code></td><td>&nbsp</td></tr>
<tr><td><code>Real</code></td><td><code>r</code></td><td>&nbsp</td></tr>
</table>
<hr><a name="householderReflection"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;householderReflection<br><span class="subtitle">Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>householderReflection</strong>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder reflection (transformation)
</p>
<blockquote>
 <strong>Ar</strong> = <strong>Q</strong>*<strong>A</strong>
</blockquote>
with
<blockquote>
 <strong>Q</strong> = <strong>I</strong> -2*<strong>u</strong>*<strong>u</strong>'/(<strong>u</strong>'*<strong>u</strong>)
</blockquote>
<p>
where <strong>u</strong> is Householder vector, i.e., the normal vector of the reflection plane.
</p>
<p>
Householder reflection is widely used in numerical linear algebra, e.g., to perform QR decompositions.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];

  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u= {0.763, 0.646, 0}

  Ar=householderReflection(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
<a href="index.html#householderSimilarityTransformation">Matrices.Utilities.housholderSimilarityTransformation</a>,<br>
<a href="../../Vectors/Utilities/index.html#householderReflection">Vectors.Utilities.householderReflection</a>,<br>
<a href="../../Vectors/Utilities/index.html#householderVector">Vectors.Utilities.householderVector</a>
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>A[:,:]</code></td><td>Rectangular matrix</td></tr>
<tr><td><code>Real</code></td><td><code>u[size(A, 1)]</code></td><td>Householder vector</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>RA[size(A, 1),size(A, 2)]</code></td><td>Reflexion of A</td></tr>
</table>
<hr><a name="householderSimilarityTransformation"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;householderSimilarityTransformation<br><span class="subtitle">Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u'</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
  As = Matrices.<strong>householderSimilarityTransformation</strong>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder similarity transformation
</p>
<blockquote>
 <strong>As</strong> = <strong>S</strong>*<strong>A</strong>*<strong>S</strong>
</blockquote>
with
<blockquote>
 <strong>S</strong> = <strong>I</strong> -2*<strong>u</strong>*<strong>u</strong>'/(<strong>u</strong>'*<strong>u</strong>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};

  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}

  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
<a href="index.html#householderReflection">Matrices.Utilities.householderReflection</a>,<br>
<a href="../../Vectors/Utilities/index.html#householderReflection">Vectors.Utilities.householderReflection</a>,<br>
<a href="../../Vectors/Utilities/index.html#householderVector">Vectors.Utilities.householderVector</a>
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>A[:,size(A, 1)]</code></td><td>Square matrix A</td></tr>
<tr><td><code>Real</code></td><td><code>u[size(A, 1)]</code></td><td>Householder vector</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>SAS[size(A, 1),size(A, 1)]</code></td><td>Transformation of matrix A</td></tr>
</table>
<hr><a name="toUpperHessenberg"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;toUpperHessenberg<br><span class="subtitle">Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q' * A * Q = H</span></h2></a>
<h3>Information</h3>
<p>

   <h4>Syntax</h4>
<blockquote><pre>
         H = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A);
         (H, V, tau, info) = Matrices.Utilities.<strong>toUpperHessenberg</strong>(A,ilo, ihi);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>toUpperHessenberg</strong> computes a upper Hessenberg form <strong>H</strong> of a matrix <strong>A</strong> by orthogonal similarity transformation:  <strong>Q</strong>' * <strong>A</strong> * <strong>Q</strong> = <strong>H</strong>.
With the optional inputs ilo and ihi, also partial transformation is possible. The function calls LAPACK function DGEHRD.
See <a href="../LAPACK/index.html#dgehrd">Matrices.LAPACK.dgehrd</a> for more information about the additional outputs V, tau, info and inputs ilo, ihi.
</p>

<h4>Example</h4>
<blockquote><pre>
 A  = [1, 2, 3;
       6, 5, 4;
       1, 0, 0];

 H = toUpperHessenberg(A);

  results in:

 H = [1.0,  -2.466,  2.630;
     -6.083, 5.514, -3.081;
      0.0,   0.919, -0.514]

</pre></blockquote>

<h4>See also</h4>
<a href="../index.html#hessenberg">Matrices.hessenberg</a>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>A[:,size(A, 1)]</code></td><td>Square matrix A</td></tr>
<tr><td><code>Integer</code></td><td><code>ilo</code></td><td>Lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td><code>Integer</code></td><td><code>ihi</code></td><td>Highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>H[size(A, 1),size(A, 2)]</code></td><td>Upper Hessenberg form</td></tr>
<tr><td><code>Real</code></td><td><code>V[size(A, 1),size(A, 2)]</code></td><td>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</td></tr>
<tr><td><code>Real</code></td><td><code>tau[max(0, size(A, 1) - 1)]</code></td><td>Scalar factors of the elementary reflectors</td></tr>
<tr><td><code>Integer</code></td><td><code>info</code></td><td>Information of successful function call</td></tr>
</table>
<hr><a name="eigenvaluesHessenberg"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;eigenvaluesHessenberg<br><span class="subtitle">Compute eigenvalues of an upper Hessenberg form matrix</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
           ev = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
   (ev, info) = Matrices.Utilities.<strong>eigenvaluesHessenberg</strong>(H);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the eigenvalues of a Hessenberg form matrix. Transformation to Hessenberg form is the first step in eigenvalue computation for arbitrary matrices with QR decomposition.
This step can be skipped if the matrix has already Hessenberg form.
</p>

<p>
The function uses the LAPACK-routine dhseqr. Output <code>info</code> is 0 for a successful call of this
function.<br>
See <a href="../LAPACK/index.html#dhseqr">Matrices.LAPACK.dhseqr</a> for details
</p>

<h4>Example</h4>
<blockquote><pre>
     Real A[3,3] = [1,2,3;
                    9,8,7;
                    0,1,0];

     Real ev[3,2];

     ev := Matrices.Utilities.eigenvaluesHessenberg(A);

  // ev  = [10.7538,    0.0;
            -0.8769,    1.0444;
            -0.8769,   -1.0444]
  // = {10.7538,  -0.8769 +- i*1.0444}
</pre></blockquote>
<br>

<h4>See also</h4>
<p>
<a href="../index.html#eigenValues">Matrices.eigenValues</a>,
<a href="../index.html#hessenberg">Matrices.hessenberg</a>
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>H[:,size(H, 1)]</code></td><td>Hessenberg matrix H</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>ev[size(H, 1),2]</code></td><td>Eigenvalues</td></tr>
<tr><td><code>Integer</code></td><td><code>info</code></td><td>&nbsp</td></tr>
</table>
<hr><a name="reorderRSF"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;reorderRSF<br><span class="subtitle">Reorders a real Schur form to clusters of stable and unstable eigenvalues</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
              To = Matrices.Utilities.<strong>reorderRSF</strong>(T, Q, alphaReal, alphaImag);
(To, Qo, wr, wi) = Matrices.Utilities.<strong>reorderRSF</strong>(T, Q, alphaReal, alphaImag, iscontinuous);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>reorderRSF</strong>() reorders a real Schur form such that the stable eigenvalues of
the system are in the 1-by-1 and 2-by-2 diagonal blocks of the block <strong>upper</strong> triangular matrix.
If the Schur form is referenced to a continuous system the staple eigenvalues are in the left complex half plane.
The stable eigenvalues of a discrete system are inside the complex unit circle.<br>
This function is used for example to solve algebraic Riccati equations
(<a href="../index.html#continuousRiccati">continuousRiccati</a>,
<a href="../index.html#discreteRiccati">discreteRiccati</a>). In this context the Schur form
as well as the corresponding eigenvalues and the transformation matrix <strong>Q</strong> are known, why the eigenvalues and the transformation matrix are inputs to <strong>reorderRSF()</strong>.<br>

The Schur vector matrix <strong>Qo</strong> is also reordered according to <strong>To</strong>. The vectors <strong>wr</strong> and <strong>wi</strong> contains the real and imaginary parts of the
reordered eigenvalues respectively.
</p>

<h4>Example</h4>
<blockquote><pre>
  T := [-1,2, 3,4;
         0,2, 6,5;
         0,0,-3,5;
         0,0, 0,6];
  To := Matrices.Utilities.reorderRSF(T,identity(4),{-1, 2, -3, 6},{0, 0, 0, 0}, true);

  // To = [-1.0, -0.384, 3.585, 4.0;
  //        0.0, -3.0,   6.0,   0.64;
  //        0.0,  0.0,   2.0,   7.04;
  //        0.0,  0.0,   0.0,   6.0]
</pre></blockquote>
<p>
See also <a href="../index.html#realSchur">Matrices.realSchur</a>
</p>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>T[:,:]</code></td><td>Real Schur form</td></tr>
<tr><td><code>Real</code></td><td><code>Q[:,size(T, 2)]</code></td><td>Schur vector Matrix</td></tr>
<tr><td><code>Real</code></td><td><code>alphaReal[size(T, 1)]</code></td><td>Real part of eigenvalue=alphaReal+i*alphaImag</td></tr>
<tr><td><code>Real</code></td><td><code>alphaImag[size(T, 1)]</code></td><td>Imaginary part of eigenvalue=alphaReal+i*alphaImag</td></tr>
<tr><td><code>Boolean</code></td><td><code>iscontinuous</code></td><td>True if the according system is continuous. False for discrete systems</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>To[size(T, 1),size(T, 2)]</code></td><td>Reordered Schur form</td></tr>
<tr><td><code>Real</code></td><td><code>Qo[size(T, 1),size(T, 2)]</code></td><td>Reordered Schur vector matrix</td></tr>
<tr><td><code>Real</code></td><td><code>wr[size(T, 2)]</code></td><td>Reordered eigenvalues, real part</td></tr>
<tr><td><code>Real</code></td><td><code>wi[size(T, 2)]</code></td><td>Reordered eigenvalues, imaginary part</td></tr>
</table>
<hr><a name="findLocal_tk"><h2><embed class="icon" src="../../../images/icon0035.svg" width="203" height="203" />
Function <a href="../../../index.html">Modelica</a>.&#8203;<a href="../../index.html">Math</a>.&#8203;<a href="../index.html">Matrices</a>.&#8203;<a href="index.html">Utilities</a>.&#8203;findLocal_tk<br><span class="subtitle">Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</span></h2></a>
<h3>Information</h3>
<p>

<h4>Syntax</h4>
<blockquote><pre>
           tk = Matrices.Utilities.<strong>findLocal_tk</strong>(Rk, Vk);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <code>findLocal_tk()</code> is an auxiliary function called in iterative solver for algebraic Riccati equation based on Newton's method with
exact line search like <a href="index.html#continuousRiccatiIterative">continuousRiccatiIterative</a><br>
and <a href="index.html#discreteRiccatiIterative">discreteRiccatiIterative</a>.<br>
The function computes the local minimum of the function f_k(t_k)
</p>
<blockquote><pre>
  f_k(t_k) = alpha_k*(1-t_k)^2 + 2*beta_k*(1-t)*t^2 + gamma_k*t^4
</pre></blockquote>
<p>
by calculating the zeros of the derivation d f_k/d t_k. It is known that the function f_k(t_k) has a local minimum at some value t_k_min in [0, 2].<br>
With t_k_min the norm of the next residual of the algorithm will be minimized.<br>
See [1] for more information
</p>
<h4>References</h4>
<pre>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
</pre>

<h4>See also</h4>
<a href="index.html#continuousRiccatiIterative">Matrices.Utilities.continuousRiccatiIterative</a><br>
<a href="index.html#discreteRiccatiIterative">Matrices.Utilities.discreteRiccatiIterative</a><br>
<p>Extends from <code><a href="../../../Icons/index.html#Function">Modelica.&#8203;Icons.&#8203;Function</a></code> (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>Rk[:,size(Rk, 1)]</code></td><td>&nbsp</td></tr>
<tr><td><code>Real</code></td><td><code>Vk[size(Rk, 1),size(Rk, 2)]</code></td><td>&nbsp</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Type</th><th>Name</th><th>Description</th></tr><tr><td><code>Real</code></td><td><code>tk</code></td><td>&nbsp</td></tr>
</table>
<hr style="border-color:#999" />
<p style="font-size:80%;color:#999;margin-top:12px">Generated 2018-10-22 14:49:32 EDT by <i>MapleSim</i>.</p>
</body></html>
