/* DSblock model generated by Dymola from Modelica model Modelica.Electrical.Analog.Examples.HeatingNPN_OrGate
 Dymola Version 7.1, 2008-10-03 translated this at Tue May 05 15:37:47 2009

  Advanced.NewStateSelection = true; // Due to used package.
 */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#include <moutil.c>
const char*modelName="Modelica.Electrical.Analog.Examples.HeatingNPN_OrGate";
const char*usedLibraries[]={0};
const char*default_dymosim_license_filename=
 "c:/programme/dymola 7.1/insert/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = 0;
W_[1] = 0;
W_[44] = false;
W_[48] = false;
W_[53] = false;
W_[87] = true;
W_[117] = true;
W_[65] = 0;
W_[70] = 0;
W_[75] = 0;
W_[82] = 0;
W_[83] = 0;
W_[84] = 0;
W_[85] = 0;
W_[86] = 0;
W_[112] = 0;
W_[113] = 0;
W_[114] = 0;
W_[115] = 0;
W_[116] = 0;
W_[61] = 0;
W_[64] = 0;
W_[63] = 0;
W_[62] = 0;
W_[66] = 0;
W_[69] = 0;
W_[68] = 0;
W_[67] = 0;
W_[71] = 0;
W_[74] = 0;
W_[73] = 0;
W_[72] = 0;
W_[56] = 0;
W_[57] = 0;
W_[58] = 0;
W_[59] = 0;
W_[60] = 0;
W_[77] = 0;
W_[76] = 0;
W_[79] = 0;
W_[78] = 0;
W_[81] = 0;
W_[80] = 0;
W_[100] = 0;
W_[99] = 0;
W_[110] = 0;
W_[95] = 0;
W_[96] = 0;
W_[130] = 0;
W_[129] = 0;
W_[139] = 0;
W_[125] = 0;
W_[126] = 0;
W_[6] = 0;
W_[12] = 0;
W_[28] = 0;
BoundParameterSection
W_[7] = DP_[3];
W_[8] = DP_[4];
W_[9] = DP_[5];
W_[10] = DP_[6];
W_[13] = DP_[7];
W_[14] = DP_[8];
W_[15] = DP_[9];
W_[16] = DP_[10];
W_[17] = DP_[11];
W_[18] = DP_[12];
W_[19] = DP_[13];
W_[20] = DP_[14];
W_[21] = W_[14];
W_[22] = W_[21]+W_[15];
W_[23] = W_[22]+W_[16];
W_[29] = DP_[15];
W_[30] = DP_[16];
W_[31] = DP_[17];
W_[32] = DP_[18];
W_[33] = DP_[19];
W_[34] = DP_[20];
W_[35] = DP_[21];
W_[36] = DP_[22];
W_[37] = W_[30];
W_[38] = W_[37]+W_[31];
W_[39] = W_[38]+W_[32];
W_[46] = DP_[24];
W_[50] = DP_[26];
W_[55] = DP_[28];
W_[97] = exp(DP_[39]);
W_[98] = exp(DP_[40]);
W_[127] = exp(DP_[59]);
W_[128] = exp(DP_[60]);
InitialSection
#ifdef DynSimStruct
W_[104] = 0.01;
W_[134] = 0.01;
F_[0] = 0;
#endif
InitialSection2
W_[24] = W_[20];
W_[25] = W_[18];
W_[26] = W_[18];
W_[40] = W_[36];
W_[41] = W_[34];
W_[42] = W_[34];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
Aux_[0] = W_[24];
Aux_[2] = W_[26];
Aux_[1] = W_[25];
Aux_[3] = W_[40];
Aux_[5] = W_[42];
Aux_[4] = W_[41];
InitialSection
Aux_[0] = W_[20];
InitialSection2
W_[24] = Aux_[0];
InitialSection
Aux_[3] = W_[36];
InitialSection2
W_[40] = Aux_[3];
InitialSection
Aux_[2] = W_[18];
InitialSection2
W_[26] = Aux_[2];
InitialSection
Aux_[5] = W_[34];
InitialSection2
W_[42] = Aux_[5];
InitialSection
Aux_[1] = W_[18];
InitialSection2
W_[25] = Aux_[1];
InitialSection
Aux_[4] = W_[34];
InitialSection2
W_[41] = Aux_[4];
InitialSection
Init=false;InitializeData(2);Init=true;

OutputSection

DynamicsSection
beginwhenBlock
helpvar[0] = sample(W_[20], W_[17], 0);
whenModelicaOld(PRE(W_[26], 0) != 0 AND helpvar[0], 0) 
  W_[26] = PRE(W_[25], 1);
endwhenModelica()
endwhenBlock
beginwhenBlock
whenModelicaOld(PRE(W_[26], 0) != 0 AND helpvar[0], 1) 
  W_[24] = Time;
endwhenModelica()
endwhenBlock
W_[11] = W_[19]+(IF LessTime(W_[20], 0) OR W_[26] == 0 OR GreaterEqualTime(
  W_[24]+W_[23], 1) THEN 0 ELSE IF LessTime(W_[24]+W_[21], 2) THEN divmacro((
  Time-W_[24])*W_[13],"(time-V1.signalSource.T0)*V1.signalSource.amplitude",
  W_[21],"V1.signalSource.T_rising") ELSE IF LessTime(W_[24]+W_[22], 3) THEN 
  W_[13] ELSE divmacro((W_[24]+W_[23]-Time)*W_[13],"(V1.signalSource.T0+V1.signalSource.T_falling-time)*V1.signalSource.amplitude",
  W_[23]-W_[22],"V1.signalSource.T_falling-V1.signalSource.T_width"));
W_[5] = W_[9]+(IF LessTime(W_[10], 4) THEN 0 ELSE IF LessTime(W_[10]+W_[8], 5)
   THEN divmacro((Time-W_[10])*W_[7],"(time-V.signalSource.startTime)*V.signalSource.height",
  W_[8],"V.signalSource.duration") ELSE W_[7]);
beginwhenBlock
helpvar[1] = sample(W_[36], W_[33], 1);
whenModelicaOld(PRE(W_[42], 2) != 0 AND helpvar[1], 2) 
  W_[42] = PRE(W_[41], 3);
endwhenModelica()
endwhenBlock
beginwhenBlock
whenModelicaOld(PRE(W_[42], 2) != 0 AND helpvar[1], 3) 
  W_[40] = Time;
endwhenModelica()
endwhenBlock
W_[27] = W_[35]+(IF LessTime(W_[36], 6) OR W_[42] == 0 OR GreaterEqualTime(
  W_[40]+W_[39], 7) THEN 0 ELSE IF LessTime(W_[40]+W_[37], 8) THEN divmacro((
  Time-W_[40])*W_[29],"(time-V2.signalSource.T0)*V2.signalSource.amplitude",
  W_[37],"V2.signalSource.T_rising") ELSE IF LessTime(W_[40]+W_[38], 9) THEN 
  W_[29] ELSE divmacro((W_[40]+W_[39]-Time)*W_[29],"(V2.signalSource.T0+V2.signalSource.T_falling-time)*V2.signalSource.amplitude",
  W_[39]-W_[38],"V2.signalSource.T_falling-V2.signalSource.T_width"));
BreakSectionFunction(1);






{ /* Non-linear system of equations to solve. */
/* Introducing 341 common subexpressions used in 258 expressions */
/* Of the common subexpressions 335 are reals, 0 are integers, and 6
   are booleans. */
const char*const varnames_[]={"T2.vbc", "TC2.dT", "R2.v", "R1.v", "TC1.dT"};
const double nominal_[]={1, 1, 1, 1, 1};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 5, 0, 1, 0);
SetInitVector(x__, 1, W_[120], Remember_(W_[120], 0));
SetInitVector(x__, 2, W_[4], Remember_(W_[4], 1));
SetInitVector(x__, 3, W_[47], Remember_(W_[47], 2));
SetInitVector(x__, 4, W_[43], Remember_(W_[43], 3));
SetInitVector(x__, 5, W_[3], Remember_(W_[3], 4));
Residues;
  W_[122] = 1-W_[120]*DP_[52];
  W_[119] = W_[4]+X_[0];
  helpvar[2] = divmacro(W_[119],"T2.internalHeatPort.T",DP_[61],"T2.Tnom");
  helpvar[3] = divmacro(1,"1",DP_[61],"T2.Tnom");
  helpvar[4] = powmacro(helpvar[2],"T2.internalHeatPort.T/T2.Tnom",DP_[63],
    "T2.XTB");
  W_[132] = DP_[50]*helpvar[4];
  helpvar[5] = divmacro(1,"1",DP_[68],"T2.q");
  W_[134] = helpvar[5]*DP_[67]*W_[119];
  helpvar[6] = (helpvar[2]-1)*DP_[64];
  helpvar[7] = divmacro(1,"1",W_[134],"T2.vt_t");
  W_[135] = helpvar[7]*helpvar[6];
  helpvar[8] = LessS(W_[135],"T2.hexp", DP_[59],"T2.EMin", 0);
  W_[136] = IF helpvar[8] THEN W_[127]*(1+W_[135]-DP_[59]) ELSE IF GreaterS(
    W_[135],"T2.hexp", DP_[60],"T2.EMax", 1) THEN W_[128]*(1+W_[135]-DP_[60])
     ELSE exp(W_[135]);
  helpvar[9] = DP_[51]*powmacro(helpvar[2],"T2.internalHeatPort.T/T2.Tnom",
    DP_[62],"T2.XTI");
  W_[131] = helpvar[9]*W_[136];
  helpvar[10] = DP_[66]*W_[134];
  helpvar[11] = divmacro(W_[120],"T2.vbc",helpvar[10],"T2.NR*T2.vt_t");
  helpvar[12] = LessS(helpvar[11],"T2.vbc/(T2.NR*T2.vt_t)", DP_[59],"T2.EMin", 2);
  W_[123] = IF helpvar[12] THEN W_[131]*(W_[127]*(1+divmacro(W_[120],"T2.vbc",
    helpvar[10],"T2.NR*T2.vt_t")-DP_[59])-1)+W_[120]*DP_[57] ELSE IF GreaterS(
    helpvar[11],"T2.vbc/(T2.NR*T2.vt_t)", DP_[60],"T2.EMax", 3) THEN W_[131]*(
    W_[128]*(1+divmacro(W_[120],"T2.vbc",helpvar[10],"T2.NR*T2.vt_t")-DP_[60])-1)
    +W_[120]*DP_[57] ELSE W_[131]*(exp(divmacro(W_[120],"T2.vbc",helpvar[10],
    "T2.NR*T2.vt_t"))-1)+W_[120]*DP_[57];
  W_[118] = DP_[2]*W_[4];
  W_[133] = DP_[49]*helpvar[4];
  W_[121] = W_[27]-W_[47];
  helpvar[13] = DP_[65]*W_[134];
  helpvar[14] = divmacro(W_[121],"T2.vbe",helpvar[13],"T2.NF*T2.vt_t");
  helpvar[15] = LessS(helpvar[14],"T2.vbe/(T2.NF*T2.vt_t)", DP_[59],"T2.EMin", 4);
  W_[124] = IF helpvar[15] THEN W_[131]*(W_[127]*(1+divmacro(W_[121],"T2.vbe",
    helpvar[13],"T2.NF*T2.vt_t")-DP_[59])-1)+W_[121]*DP_[58] ELSE IF GreaterS(
    helpvar[14],"T2.vbe/(T2.NF*T2.vt_t)", DP_[60],"T2.EMax", 5) THEN W_[131]*(
    W_[128]*(1+divmacro(W_[121],"T2.vbe",helpvar[13],"T2.NF*T2.vt_t")-DP_[60])-1)
    +W_[121]*DP_[58] ELSE W_[131]*(exp(divmacro(W_[121],"T2.vbe",helpvar[13],
    "T2.NF*T2.vt_t"))-1)+W_[121]*DP_[58];
  helpvar[16] = divmacro(W_[124],"T2.ibe",W_[133],"T2.bf_t");
  helpvar[17] = divmacro(1,"1",W_[133],"T2.bf_t");
  helpvar[18] = divmacro(W_[123],"T2.ibc",W_[132],"T2.br_t");
  helpvar[19] = divmacro(1,"1",W_[132],"T2.br_t");
  W_[138] = helpvar[16]+helpvar[18];
  helpvar[20] = W_[124]-W_[123];
  helpvar[21] = helpvar[20]*W_[122];
  W_[137] = helpvar[21]-helpvar[18];
  W_[89] = W_[3]+X_[0];
  helpvar[22] = divmacro(1,"1",DP_[48],"T1.q");
  W_[104] = helpvar[22]*DP_[47]*W_[89];
  helpvar[23] = divmacro(W_[89],"T1.internalHeatPort.T",DP_[41],"T1.Tnom");
  helpvar[24] = divmacro(1,"1",DP_[41],"T1.Tnom");
  helpvar[25] = (helpvar[23]-1)*DP_[44];
  helpvar[26] = divmacro(1,"1",W_[104],"T1.vt_t");
  W_[105] = helpvar[26]*helpvar[25];
  helpvar[27] = LessS(W_[105],"T1.hexp", DP_[39],"T1.EMin", 6);
  W_[106] = IF helpvar[27] THEN W_[97]*(1+W_[105]-DP_[39]) ELSE IF GreaterS(
    W_[105],"T1.hexp", DP_[40],"T1.EMax", 7) THEN W_[98]*(1+W_[105]-DP_[40])
     ELSE exp(W_[105]);
  helpvar[28] = DP_[31]*powmacro(helpvar[23],"T1.internalHeatPort.T/T1.Tnom",
    DP_[42],"T1.XTI");
  W_[101] = helpvar[28]*W_[106];
  W_[91] = W_[11]-W_[43];
  W_[90] = W_[120]-W_[121]+W_[91];
  W_[92] = 1-W_[90]*DP_[32];
  helpvar[29] = powmacro(helpvar[23],"T1.internalHeatPort.T/T1.Tnom",DP_[43],
    "T1.XTB");
  W_[103] = DP_[29]*helpvar[29];
  W_[102] = DP_[30]*helpvar[29];
  helpvar[30] = DP_[46]*W_[104];
  helpvar[31] = divmacro(W_[90],"T1.vbc",helpvar[30],"T1.NR*T1.vt_t");
  helpvar[32] = LessS(helpvar[31],"T1.vbc/(T1.NR*T1.vt_t)", DP_[39],"T1.EMin", 8);
  W_[93] = IF helpvar[32] THEN W_[101]*(W_[97]*(1+divmacro(W_[90],"T1.vbc",
    helpvar[30],"T1.NR*T1.vt_t")-DP_[39])-1)+W_[90]*DP_[37] ELSE IF GreaterS(
    helpvar[31],"T1.vbc/(T1.NR*T1.vt_t)", DP_[40],"T1.EMax", 9) THEN W_[101]*(
    W_[98]*(1+divmacro(W_[90],"T1.vbc",helpvar[30],"T1.NR*T1.vt_t")-DP_[40])-1)+
    W_[90]*DP_[37] ELSE W_[101]*(exp(divmacro(W_[90],"T1.vbc",helpvar[30],
    "T1.NR*T1.vt_t"))-1)+W_[90]*DP_[37];
  helpvar[33] = DP_[45]*W_[104];
  helpvar[34] = divmacro(W_[91],"T1.vbe",helpvar[33],"T1.NF*T1.vt_t");
  helpvar[35] = LessS(helpvar[34],"T1.vbe/(T1.NF*T1.vt_t)", DP_[39],"T1.EMin", 10);
  W_[94] = IF helpvar[35] THEN W_[101]*(W_[97]*(1+divmacro(W_[91],"T1.vbe",
    helpvar[33],"T1.NF*T1.vt_t")-DP_[39])-1)+W_[91]*DP_[38] ELSE IF GreaterS(
    helpvar[34],"T1.vbe/(T1.NF*T1.vt_t)", DP_[40],"T1.EMax", 11) THEN W_[101]*(
    W_[98]*(1+divmacro(W_[91],"T1.vbe",helpvar[33],"T1.NF*T1.vt_t")-DP_[40])-1)+
    W_[91]*DP_[38] ELSE W_[101]*(exp(divmacro(W_[91],"T1.vbe",helpvar[33],
    "T1.NF*T1.vt_t"))-1)+W_[91]*DP_[38];
  helpvar[36] = W_[94]-W_[93];
  helpvar[37] = helpvar[36]*W_[92];
  helpvar[38] = divmacro(W_[93],"T1.ibc",W_[102],"T1.br_t");
  helpvar[39] = divmacro(1,"1",W_[102],"T1.br_t");
  W_[108] = helpvar[37]-helpvar[38];
  W_[52] =  -(W_[108]+W_[137]);
  W_[107] = W_[91]-W_[90];
  W_[51] = W_[107]-W_[5];
  helpvar[40] = divmacro(W_[94],"T1.ibe",W_[103],"T1.bf_t");
  helpvar[41] = divmacro(1,"1",W_[103],"T1.bf_t");
  W_[109] = helpvar[40]+helpvar[38];
  W_[88] = DP_[1]*W_[3];
helpvar[42] = W_[90]*W_[93];
helpvar[43] = W_[91]*W_[94];
helpvar[44] = W_[120]*W_[123];
helpvar[45] = W_[121]*W_[124];
SetVector(residue__, 1, DP_[23]*W_[109]-W_[43]);
SetVector(residue__, 2, DP_[25]*W_[138]-W_[47]);
SetVector(residue__, 3, DP_[27]*W_[52]-W_[51]);
SetVector(residue__, 4, W_[88]-(helpvar[39]*helpvar[42]+helpvar[41]*helpvar[43]+
  helpvar[37]*W_[107]));
SetVector(residue__, 5, W_[118]-(helpvar[19]*helpvar[44]+helpvar[17]*helpvar[45]
  +helpvar[21]*W_[107]));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[46] = IF helpvar[32] THEN divmacro(W_[101]*W_[97],"T1.is_t*T1.ExMin",
  helpvar[30],"T1.NR*T1.vt_t")+DP_[37] ELSE IF GreaterS(helpvar[31],
  "T1.vbc/(T1.NR*T1.vt_t)", DP_[40],"T1.EMax", 9) THEN divmacro(W_[101]*W_[98],
  "T1.is_t*T1.ExMax",helpvar[30],"T1.NR*T1.vt_t")+DP_[37] ELSE divmacro(W_[101]*
  exp(divmacro(W_[90],"T1.vbc",helpvar[30],"T1.NR*T1.vt_t")),"T1.is_t*exp(T1.vbc/(T1.NR*T1.vt_t))",
  helpvar[30],"T1.NR*T1.vt_t")+DP_[37];
helpvar[47] = helpvar[39]*helpvar[46]*DP_[23];
helpvar[48] = IF helpvar[35] THEN divmacro(W_[101]*W_[97],"T1.is_t*T1.ExMin",
  helpvar[33],"T1.NF*T1.vt_t")+DP_[38] ELSE IF GreaterS(helpvar[34],
  "T1.vbe/(T1.NF*T1.vt_t)", DP_[40],"T1.EMax", 11) THEN divmacro(W_[101]*W_[98],
  "T1.is_t*T1.ExMax",helpvar[33],"T1.NF*T1.vt_t")+DP_[38] ELSE divmacro(W_[101]*
  exp(divmacro(W_[91],"T1.vbe",helpvar[33],"T1.NF*T1.vt_t")),"T1.is_t*exp(T1.vbe/(T1.NF*T1.vt_t))",
  helpvar[33],"T1.NF*T1.vt_t")+DP_[38];
helpvar[49] = IF helpvar[32] THEN  -divmacro(W_[101]*W_[97]*W_[90]*DP_[46],
  "T1.is_t*T1.ExMin*T1.vbc*T1.NR",sqr(helpvar[30]),"(T1.NR*T1.vt_t)^2") ELSE IF 
  GreaterS(helpvar[31],"T1.vbc/(T1.NR*T1.vt_t)", DP_[40],"T1.EMax", 9) THEN  -
  divmacro(W_[101]*W_[98]*W_[90]*DP_[46],"T1.is_t*T1.ExMax*T1.vbc*T1.NR",sqr(
  helpvar[30]),"(T1.NR*T1.vt_t)^2") ELSE  -divmacro(W_[101]*exp(divmacro(W_[90],
  "T1.vbc",helpvar[30],"T1.NR*T1.vt_t"))*W_[90]*DP_[46],"T1.is_t*exp(T1.vbc/(T1.NR*T1.vt_t))*T1.vbc*T1.NR",
  sqr(helpvar[30]),"(T1.NR*T1.vt_t)^2");
helpvar[50] = IF helpvar[27] THEN W_[97] ELSE IF GreaterS(W_[105],"T1.hexp", 
  DP_[40],"T1.EMax", 7) THEN W_[98] ELSE exp(W_[105]);
helpvar[51] = IF helpvar[32] THEN W_[97]*(1+divmacro(W_[90],"T1.vbc",helpvar[30],
  "T1.NR*T1.vt_t")-DP_[39])-1 ELSE IF GreaterS(helpvar[31],"T1.vbc/(T1.NR*T1.vt_t)",
   DP_[40],"T1.EMax", 9) THEN W_[98]*(1+divmacro(W_[90],"T1.vbc",helpvar[30],
  "T1.NR*T1.vt_t")-DP_[40])-1 ELSE exp(divmacro(W_[90],"T1.vbc",helpvar[30],
  "T1.NR*T1.vt_t"))-1;
helpvar[52] = IF helpvar[35] THEN W_[97]*(1+divmacro(W_[91],"T1.vbe",helpvar[33],
  "T1.NF*T1.vt_t")-DP_[39])-1 ELSE IF GreaterS(helpvar[34],"T1.vbe/(T1.NF*T1.vt_t)",
   DP_[40],"T1.EMax", 11) THEN W_[98]*(1+divmacro(W_[91],"T1.vbe",helpvar[33],
  "T1.NF*T1.vt_t")-DP_[40])-1 ELSE exp(divmacro(W_[91],"T1.vbe",helpvar[33],
  "T1.NF*T1.vt_t"))-1;
helpvar[53] = helpvar[39]*helpvar[51]*DP_[23]+helpvar[41]*helpvar[52]*DP_[23];
helpvar[54] = helpvar[28]*helpvar[53];
helpvar[55] = helpvar[50]*helpvar[54];
helpvar[56] = sqr(W_[104]);
helpvar[57] = divmacro(1,"1",helpvar[56],"T1.vt_t^2");
helpvar[58] = IF helpvar[35] THEN  -divmacro(W_[101]*W_[97]*W_[91]*DP_[45],
  "T1.is_t*T1.ExMin*T1.vbe*T1.NF",sqr(helpvar[33]),"(T1.NF*T1.vt_t)^2") ELSE IF 
  GreaterS(helpvar[34],"T1.vbe/(T1.NF*T1.vt_t)", DP_[40],"T1.EMax", 11) THEN  -
  divmacro(W_[101]*W_[98]*W_[91]*DP_[45],"T1.is_t*T1.ExMax*T1.vbe*T1.NF",sqr(
  helpvar[33]),"(T1.NF*T1.vt_t)^2") ELSE  -divmacro(W_[101]*exp(divmacro(W_[91],
  "T1.vbe",helpvar[33],"T1.NF*T1.vt_t"))*W_[91]*DP_[45],"T1.is_t*exp(T1.vbe/(T1.NF*T1.vt_t))*T1.vbe*T1.NF",
  sqr(helpvar[33]),"(T1.NF*T1.vt_t)^2");
helpvar[59] = DP_[47]*(helpvar[39]*helpvar[49]*DP_[23]-helpvar[57]*helpvar[25]*
  helpvar[55]+helpvar[41]*helpvar[58]*DP_[23]);
helpvar[60] = helpvar[24]*DP_[44]*helpvar[55];
helpvar[61] = W_[106]*DP_[31]*powmacro(helpvar[23],"T1.internalHeatPort.T/T1.Tnom",
  DP_[42]-1,"T1.XTI-1")*DP_[42];
helpvar[62] = powmacro(helpvar[23],"T1.internalHeatPort.T/T1.Tnom",DP_[43]-1,
  "T1.XTB-1")*DP_[43];
helpvar[63] = DP_[29]*helpvar[62];
helpvar[64] = W_[94]*DP_[23];
helpvar[65] = sqr(W_[103]);
helpvar[66] = divmacro(1,"1",helpvar[65],"T1.bf_t^2");
helpvar[67] = DP_[30]*helpvar[62];
helpvar[68] = sqr(W_[102]);
helpvar[69] = divmacro(1,"1",helpvar[68],"T1.br_t^2");
helpvar[70] = IF helpvar[12] THEN divmacro(W_[131]*W_[127],"T2.is_t*T2.ExMin",
  helpvar[10],"T2.NR*T2.vt_t")+DP_[57] ELSE IF GreaterS(helpvar[11],
  "T2.vbc/(T2.NR*T2.vt_t)", DP_[60],"T2.EMax", 3) THEN divmacro(W_[131]*W_[128],
  "T2.is_t*T2.ExMax",helpvar[10],"T2.NR*T2.vt_t")+DP_[57] ELSE divmacro(W_[131]*
  exp(divmacro(W_[120],"T2.vbc",helpvar[10],"T2.NR*T2.vt_t")),"T2.is_t*exp(T2.vbc/(T2.NR*T2.vt_t))",
  helpvar[10],"T2.NR*T2.vt_t")+DP_[57];
helpvar[71] = IF helpvar[12] THEN  -divmacro(W_[131]*W_[127]*W_[120]*DP_[66],
  "T2.is_t*T2.ExMin*T2.vbc*T2.NR",sqr(helpvar[10]),"(T2.NR*T2.vt_t)^2") ELSE IF 
  GreaterS(helpvar[11],"T2.vbc/(T2.NR*T2.vt_t)", DP_[60],"T2.EMax", 3) THEN  -
  divmacro(W_[131]*W_[128]*W_[120]*DP_[66],"T2.is_t*T2.ExMax*T2.vbc*T2.NR",sqr(
  helpvar[10]),"(T2.NR*T2.vt_t)^2") ELSE  -divmacro(W_[131]*exp(divmacro(W_[120],
  "T2.vbc",helpvar[10],"T2.NR*T2.vt_t"))*W_[120]*DP_[66],"T2.is_t*exp(T2.vbc/(T2.NR*T2.vt_t))*T2.vbc*T2.NR",
  sqr(helpvar[10]),"(T2.NR*T2.vt_t)^2");
helpvar[72] = IF helpvar[8] THEN W_[127] ELSE IF GreaterS(W_[135],"T2.hexp", 
  DP_[60],"T2.EMax", 1) THEN W_[128] ELSE exp(W_[135]);
helpvar[73] = IF helpvar[12] THEN W_[127]*(1+divmacro(W_[120],"T2.vbc",helpvar[10],
  "T2.NR*T2.vt_t")-DP_[59])-1 ELSE IF GreaterS(helpvar[11],"T2.vbc/(T2.NR*T2.vt_t)",
   DP_[60],"T2.EMax", 3) THEN W_[128]*(1+divmacro(W_[120],"T2.vbc",helpvar[10],
  "T2.NR*T2.vt_t")-DP_[60])-1 ELSE exp(divmacro(W_[120],"T2.vbc",helpvar[10],
  "T2.NR*T2.vt_t"))-1;
helpvar[74] = IF helpvar[15] THEN W_[127]*(1+divmacro(W_[121],"T2.vbe",helpvar[13],
  "T2.NF*T2.vt_t")-DP_[59])-1 ELSE IF GreaterS(helpvar[14],"T2.vbe/(T2.NF*T2.vt_t)",
   DP_[60],"T2.EMax", 5) THEN W_[128]*(1+divmacro(W_[121],"T2.vbe",helpvar[13],
  "T2.NF*T2.vt_t")-DP_[60])-1 ELSE exp(divmacro(W_[121],"T2.vbe",helpvar[13],
  "T2.NF*T2.vt_t"))-1;
helpvar[75] = helpvar[19]*helpvar[73]*DP_[25]+helpvar[17]*helpvar[74]*DP_[25];
helpvar[76] = helpvar[9]*helpvar[75];
helpvar[77] = helpvar[72]*helpvar[76];
helpvar[78] = sqr(W_[134]);
helpvar[79] = divmacro(1,"1",helpvar[78],"T2.vt_t^2");
helpvar[80] = IF helpvar[15] THEN  -divmacro(W_[131]*W_[127]*W_[121]*DP_[65],
  "T2.is_t*T2.ExMin*T2.vbe*T2.NF",sqr(helpvar[13]),"(T2.NF*T2.vt_t)^2") ELSE IF 
  GreaterS(helpvar[14],"T2.vbe/(T2.NF*T2.vt_t)", DP_[60],"T2.EMax", 5) THEN  -
  divmacro(W_[131]*W_[128]*W_[121]*DP_[65],"T2.is_t*T2.ExMax*T2.vbe*T2.NF",sqr(
  helpvar[13]),"(T2.NF*T2.vt_t)^2") ELSE  -divmacro(W_[131]*exp(divmacro(W_[121],
  "T2.vbe",helpvar[13],"T2.NF*T2.vt_t"))*W_[121]*DP_[65],"T2.is_t*exp(T2.vbe/(T2.NF*T2.vt_t))*T2.vbe*T2.NF",
  sqr(helpvar[13]),"(T2.NF*T2.vt_t)^2");
helpvar[81] = DP_[67]*(helpvar[19]*helpvar[71]*DP_[25]-helpvar[79]*helpvar[6]*
  helpvar[77]+helpvar[17]*helpvar[80]*DP_[25]);
helpvar[82] = powmacro(helpvar[2],"T2.internalHeatPort.T/T2.Tnom",DP_[63]-1,
  "T2.XTB-1")*DP_[63];
helpvar[83] = DP_[50]*helpvar[82];
helpvar[84] = helpvar[3]*helpvar[83]*W_[123]*DP_[25];
helpvar[85] = sqr(W_[132]);
helpvar[86] = divmacro(1,"1",helpvar[85],"T2.br_t^2");
helpvar[87] = DP_[64]*helpvar[77];
helpvar[88] = DP_[51]*powmacro(helpvar[2],"T2.internalHeatPort.T/T2.Tnom",
  DP_[62]-1,"T2.XTI-1")*DP_[62];
helpvar[89] = W_[136]*helpvar[88];
helpvar[90] = DP_[49]*helpvar[82];
helpvar[91] = sqr(W_[133]);
helpvar[92] = divmacro(1,"1",helpvar[91],"T2.bf_t^2");
helpvar[93] = IF helpvar[15] THEN divmacro(W_[131]*W_[127],"T2.is_t*T2.ExMin",
  helpvar[13],"T2.NF*T2.vt_t")+DP_[58] ELSE IF GreaterS(helpvar[14],
  "T2.vbe/(T2.NF*T2.vt_t)", DP_[60],"T2.EMax", 5) THEN divmacro(W_[131]*W_[128],
  "T2.is_t*T2.ExMax",helpvar[13],"T2.NF*T2.vt_t")+DP_[58] ELSE divmacro(W_[131]*
  exp(divmacro(W_[121],"T2.vbe",helpvar[13],"T2.NF*T2.vt_t")),"T2.is_t*exp(T2.vbe/(T2.NF*T2.vt_t))",
  helpvar[13],"T2.NF*T2.vt_t")+DP_[58];
helpvar[94] = W_[122]+helpvar[19];
helpvar[95] = helpvar[94]*DP_[27];
helpvar[96] = W_[92]+helpvar[39];
helpvar[97] = helpvar[96]*DP_[27];
helpvar[98] = DP_[32]*helpvar[36]*DP_[27]+helpvar[46]*helpvar[97];
helpvar[99] = W_[122]*DP_[27];
helpvar[100] = helpvar[73]*helpvar[95]-helpvar[74]*helpvar[99];
helpvar[101] = helpvar[72]*helpvar[9]*helpvar[100];
helpvar[102] = helpvar[71]*helpvar[95]-helpvar[79]*helpvar[6]*helpvar[101]-
  helpvar[80]*helpvar[99];
helpvar[103] = helpvar[83]*W_[123]*DP_[27];
helpvar[104] = W_[92]*DP_[27];
helpvar[105] = helpvar[51]*helpvar[97]-helpvar[52]*helpvar[104];
helpvar[106] = helpvar[50]*helpvar[28]*helpvar[105];
helpvar[107] = helpvar[49]*helpvar[97]-helpvar[57]*helpvar[25]*helpvar[106]-
  helpvar[58]*helpvar[104];
helpvar[108] = DP_[44]*helpvar[106];
helpvar[109] = W_[107]*W_[92];
helpvar[110] = helpvar[109]-helpvar[39]*W_[90];
helpvar[111] = DP_[32]*W_[107]*helpvar[36]-helpvar[38]+helpvar[46]*helpvar[110]+
  helpvar[37];
helpvar[112] = helpvar[41]*W_[91]+helpvar[109];
helpvar[113] = helpvar[51]*helpvar[110]-helpvar[52]*helpvar[112];
helpvar[114] = helpvar[50]*helpvar[28]*helpvar[113];
helpvar[115] = helpvar[22]*DP_[47]*(helpvar[49]*helpvar[110]-helpvar[57]*
  helpvar[25]*helpvar[114]-helpvar[58]*helpvar[112]);
helpvar[116] = helpvar[26]*helpvar[24]*DP_[44]*helpvar[114];
helpvar[117] = helpvar[61]*helpvar[113];
helpvar[118] = helpvar[63]*helpvar[43];
helpvar[119] = W_[107]*W_[122];
helpvar[120] = helpvar[19]*W_[120];
helpvar[121] = helpvar[119]-helpvar[120];
helpvar[122] = helpvar[86]*helpvar[3]*helpvar[83]*helpvar[44];
helpvar[123] = helpvar[17]*W_[121]+helpvar[119];
helpvar[124] = helpvar[73]*helpvar[121]-helpvar[74]*helpvar[123];
helpvar[125] = helpvar[72]*helpvar[9]*helpvar[124];
helpvar[126] = helpvar[5]*DP_[67]*(helpvar[71]*helpvar[121]-helpvar[79]*helpvar[6]
  *helpvar[125]-helpvar[80]*helpvar[123]);
helpvar[127] = helpvar[3]*DP_[64]*helpvar[125];
SetMatrixLeading(Jacobian__, 1, 1, 5, helpvar[47]);
SetMatrixLeading(Jacobian__, 1, 3, 5, helpvar[47]);
SetMatrixLeading(Jacobian__, 1, 4, 5, (-1)-(helpvar[47]+helpvar[41]*helpvar[48]*
  DP_[23]));
SetMatrixLeading(Jacobian__, 1, 5, 5, helpvar[22]*helpvar[59]+helpvar[26]*
  helpvar[60]+helpvar[24]*helpvar[61]*helpvar[53]-helpvar[66]*helpvar[24]*
  helpvar[63]*helpvar[64]-helpvar[69]*helpvar[24]*helpvar[67]*W_[93]*DP_[23]);
SetMatrixLeading(Jacobian__, 2, 1, 5, helpvar[19]*DP_[25]*helpvar[70]);
SetMatrixLeading(Jacobian__, 2, 2, 5, helpvar[5]*helpvar[81]-helpvar[86]*
  helpvar[84]+helpvar[7]*helpvar[3]*helpvar[87]+helpvar[3]*helpvar[89]*helpvar[75]
  -helpvar[92]*helpvar[3]*helpvar[90]*W_[124]*DP_[25]);
SetMatrixLeading(Jacobian__, 2, 3, 5, (-1)-helpvar[17]*helpvar[93]*DP_[25]);
SetMatrixLeading(Jacobian__, 3, 1, 5, 1+helpvar[20]*DP_[27]*DP_[52]+helpvar[95]*
  helpvar[70]+helpvar[98]);
SetMatrixLeading(Jacobian__, 3, 2, 5, helpvar[5]*DP_[67]*helpvar[102]-helpvar[86]
  *helpvar[3]*helpvar[103]+helpvar[7]*helpvar[3]*DP_[64]*helpvar[101]+helpvar[3]
  *helpvar[89]*helpvar[100]);
SetMatrixLeading(Jacobian__, 3, 3, 5, 1+helpvar[93]*helpvar[99]+helpvar[98]);
SetMatrixLeading(Jacobian__, 3, 4, 5, helpvar[48]*helpvar[104]-helpvar[98]);
SetMatrixLeading(Jacobian__, 3, 5, 5, helpvar[22]*DP_[47]*helpvar[107]+helpvar[26]
  *helpvar[24]*helpvar[108]+helpvar[24]*helpvar[61]*helpvar[105]-helpvar[69]*
  helpvar[24]*helpvar[67]*W_[93]*DP_[27]);
SetMatrixLeading(Jacobian__, 4, 1, 5, helpvar[111]);
SetMatrixLeading(Jacobian__, 4, 3, 5, helpvar[111]);
SetMatrixLeading(Jacobian__, 4, 4, 5, helpvar[37]-helpvar[111]+helpvar[40]+
  helpvar[48]*helpvar[112]);
SetMatrixLeading(Jacobian__, 4, 5, 5, helpvar[115]+helpvar[116]+helpvar[24]*
  helpvar[117]+helpvar[66]*helpvar[24]*helpvar[118]+helpvar[69]*helpvar[24]*
  helpvar[67]*helpvar[42]+DP_[1]);
SetMatrixLeading(Jacobian__, 5, 1, 5, W_[107]*helpvar[20]*DP_[52]+helpvar[121]*
  helpvar[70]+helpvar[21]-helpvar[18]);
SetMatrixLeading(Jacobian__, 5, 2, 5, helpvar[122]+helpvar[126]+helpvar[7]*
  helpvar[127]+helpvar[3]*helpvar[89]*helpvar[124]+helpvar[92]*helpvar[3]*
  helpvar[90]*helpvar[45]+DP_[2]);
SetMatrixLeading(Jacobian__, 5, 3, 5, helpvar[16]+helpvar[93]*helpvar[123]+
  helpvar[21]);

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[120] = GetVector(x__, 1);
W_[4] = GetVector(x__, 2);
W_[47] = GetVector(x__, 3);
W_[43] = GetVector(x__, 4);
W_[3] = GetVector(x__, 5);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(2);
W_[2] = W_[88]+W_[118];
 /* Linear system of equations to solve. */
F_[0] = RememberSimple_(F_[0], 5);
SolveScalarLinearParametric(DP_[0],"HeatCapacitor1.C", W_[2],"HeatCapacitor1.port.Q_flow",
   F_[0],"der(HeatCapacitor1.T)");
 /* End of Equation Block */ 
AssertModelica(Greater(W_[89],"T1.internalHeatPort.T", 0,"0", 12),
  "T1.internalHeatPort.T > 0", "temperature must be positive");
;
AssertModelica(Greater(W_[119],"T2.internalHeatPort.T", 0,"0", 13),
  "T2.internalHeatPort.T > 0", "temperature must be positive");
;

AcceptedSection1
beginwhenBlock
whenModelicaOld(PRE(W_[26], 0) != 0 AND helpvar[0], 4) 
  W_[25] = PRE(W_[25], 1)-(IF PRE(W_[25], 1) > 0 THEN 1 ELSE 0);
endwhenModelica()
endwhenBlock
beginwhenBlock
whenModelicaOld(PRE(W_[42], 2) != 0 AND helpvar[1], 5) 
  W_[41] = PRE(W_[41], 3)-(IF PRE(W_[41], 3) > 0 THEN 1 ELSE 0);
endwhenModelica()
endwhenBlock

AcceptedSection2
W_[45] = W_[43]*W_[109];
W_[49] = W_[47]*W_[138];
W_[54] = W_[51]*W_[52];
W_[111] =  -(W_[109]+W_[108]);
W_[140] =  -(W_[138]+W_[137]);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAlias(0)
StartNonAlias(0)
DeclareVariable("CapVal", "[F]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("tauVal", "[s]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("HeatCapacitor1.C", "Heat capacity of element (= cp*m) [J/K]", 0,\
 0.1, 0.0,0.0,0.0,0,560)
DeclareState("HeatCapacitor1.T", "Temperature of element [K|degC]", 0, 293.15, \
0.0,1E+100,0.0,0,560)
DeclareDerivative("HeatCapacitor1.der(T)", "der(Temperature of element) [K/s]", 0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("HeatCapacitor1.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "HeatCapacitor1.der(T)", 1, 6, 0, 0)
DeclareAlias2("HeatCapacitor1.port.T", "Port temperature [K|degC]", \
"HeatCapacitor1.T", 1, 1, 0, 4)
DeclareVariable("HeatCapacitor1.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("TC1.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
"T1.LossPower", 1, 5, 88, 0)
DeclareVariable("TC1.dT", "port_a.T - port_b.T [K,]", 0, 0.0,0.0,0.0,0,576)
DeclareAlias2("TC1.port_a.T", "Port temperature [K|degC]", "T1.internalHeatPort.T", 1,\
 5, 89, 4)
DeclareAlias2("TC1.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T1.LossPower", 1, 5, 88, 132)
DeclareAlias2("TC1.port_b.T", "Port temperature [K|degC]", "HeatCapacitor1.T", 1,\
 1, 0, 4)
DeclareAlias2("TC1.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T1.LossPower", -1, 5, 88, 132)
DeclareParameter("TC1.G", "Constant thermal conductance of material [W/K]", 1, \
0.01, 0.0,0.0,0.0,0,560)
DeclareAlias2("TC2.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
"T2.LossPower", 1, 5, 118, 0)
DeclareVariable("TC2.dT", "port_a.T - port_b.T [K,]", 0, 0.0,0.0,0.0,0,576)
DeclareAlias2("TC2.port_a.T", "Port temperature [K|degC]", "T2.internalHeatPort.T", 1,\
 5, 119, 4)
DeclareAlias2("TC2.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T2.LossPower", 1, 5, 118, 132)
DeclareAlias2("TC2.port_b.T", "Port temperature [K|degC]", "HeatCapacitor1.T", 1,\
 1, 0, 4)
DeclareAlias2("TC2.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T2.LossPower", -1, 5, 118, 132)
DeclareParameter("TC2.G", "Constant thermal conductance of material [W/K]", 2, \
0.01, 0.0,0.0,0.0,0,560)
DeclareParameter("V.V", "Height of ramp [V]", 3, 6, 0.0,0.0,0.0,0,560)
DeclareParameter("V.duration", "Duration of ramp [s]", 4, 5, 1E-060,1E+100,0.0,0,560)
DeclareVariable("V.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("V.i", "Current flowing from pin p to pin n [A]", "RI.i", 1, 5, 52,\
 0)
DeclareAlias2("V.p.v", "Potential at the pin [V]", "V.v", 1, 5, 5, 4)
DeclareAlias2("V.p.i", "Current flowing into the pin [A]", "RI.i", 1, 5, 52, 132)
DeclareVariable("V.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("V.n.i", "Current flowing into the pin [A]", "RI.i", -1, 5, 52, 132)
DeclareParameter("V.offset", "Voltage offset [V]", 5, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("V.startTime", "Time offset [s]", 6, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("V.signalSource.height", "Height of ramps [V]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("V.signalSource.duration", "Durations of ramp [s]", 2, 1E-060,\
1E+100,0.0,0,513)
DeclareVariable("V.signalSource.offset", "Offset of output signal [V]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V.signalSource.startTime", "Output = offset for time < startTime [s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("V.signalSource.y", "Connector of Real output signal [V]", "V.v", 1,\
 5, 5, 0)
DeclareParameter("V1.V", "Amplitude of trapezoid [V]", 7, 6, 0.0,0.0,0.0,0,560)
DeclareParameter("V1.rising", "Rising duration of trapezoid [s]", 8, 5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V1.width", "Width duration of trapezoid [s]", 9, 15, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V1.falling", "Falling duration of trapezoid [s]", 10, 5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V1.period", "Time for one period [s]", 11, 50, 1E-060,1E+100,\
0.0,0,560)
DeclareParameter("V1.nperiod", "Number of periods (< 0 means infinite number of periods)",\
 12, 10, 0.0,0.0,0.0,0,564)
DeclareVariable("V1.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("V1.i", "Current flowing from pin p to pin n [A]", "T1.B.i", -1, 5,\
 109, 0)
DeclareAlias2("V1.p.v", "Potential at the pin [V]", "V1.v", 1, 5, 11, 4)
DeclareAlias2("V1.p.i", "Current flowing into the pin [A]", "T1.B.i", -1, 5, 109,\
 132)
DeclareVariable("V1.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("V1.n.i", "Current flowing into the pin [A]", "T1.B.i", 1, 5, 109,\
 132)
DeclareParameter("V1.offset", "Voltage offset [V]", 13, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("V1.startTime", "Time offset [s]", 14, 55, 0.0,0.0,0.0,0,560)
DeclareVariable("V1.signalSource.amplitude", "Amplitude of trapezoid [V]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V1.signalSource.rising", "Rising duration of trapezoid [s]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("V1.signalSource.width", "Width duration of trapezoid [s]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("V1.signalSource.falling", "Falling duration of trapezoid [s]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("V1.signalSource.period", "Time for one period [s]", 1, 1E-060,\
1E+100,0.0,0,513)
DeclareVariable("V1.signalSource.nperiod", "Number of periods (< 0 means infinite number of periods)",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("V1.signalSource.offset", "Offset of output signal [V]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V1.signalSource.startTime", "Output = offset for time < startTime [s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("V1.signalSource.y", "Connector of Real output signal [V]", "V1.v", 1,\
 5, 11, 0)
DeclareVariable("V1.signalSource.T_rising", "End time of rising phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V1.signalSource.T_width", "End time of width phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V1.signalSource.T_falling", "End time of falling phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V1.signalSource.T0", "Start time of current period [s]", 0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("V1.signalSource.counter", "Period counter", 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("V1.signalSource.counter2", "", 0, 0.0,0.0,0.0,0,2692)
DeclareParameter("V2.V", "Amplitude of trapezoid [V]", 15, 6, 0.0,0.0,0.0,0,560)
DeclareParameter("V2.rising", "Rising duration of trapezoid [s]", 16, 5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V2.width", "Width duration of trapezoid [s]", 17, 15, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V2.falling", "Falling duration of trapezoid [s]", 18, 5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("V2.period", "Time for one period [s]", 19, 50, 1E-060,1E+100,\
0.0,0,560)
DeclareParameter("V2.nperiod", "Number of periods (< 0 means infinite number of periods)",\
 20, 10, 0.0,0.0,0.0,0,564)
DeclareVariable("V2.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("V2.i", "Current flowing from pin p to pin n [A]", "T2.B.i", -1, 5,\
 138, 0)
DeclareAlias2("V2.p.v", "Potential at the pin [V]", "V2.v", 1, 5, 27, 4)
DeclareAlias2("V2.p.i", "Current flowing into the pin [A]", "T2.B.i", -1, 5, 138,\
 132)
DeclareVariable("V2.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("V2.n.i", "Current flowing into the pin [A]", "T2.B.i", 1, 5, 138,\
 132)
DeclareParameter("V2.offset", "Voltage offset [V]", 21, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("V2.startTime", "Time offset [s]", 22, 65, 0.0,0.0,0.0,0,560)
DeclareVariable("V2.signalSource.amplitude", "Amplitude of trapezoid [V]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V2.signalSource.rising", "Rising duration of trapezoid [s]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("V2.signalSource.width", "Width duration of trapezoid [s]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("V2.signalSource.falling", "Falling duration of trapezoid [s]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("V2.signalSource.period", "Time for one period [s]", 1, 1E-060,\
1E+100,0.0,0,513)
DeclareVariable("V2.signalSource.nperiod", "Number of periods (< 0 means infinite number of periods)",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("V2.signalSource.offset", "Offset of output signal [V]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V2.signalSource.startTime", "Output = offset for time < startTime [s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("V2.signalSource.y", "Connector of Real output signal [V]", "V2.v", 1,\
 5, 27, 0)
DeclareVariable("V2.signalSource.T_rising", "End time of rising phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V2.signalSource.T_width", "End time of width phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V2.signalSource.T_falling", "End time of falling phase within one period [s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("V2.signalSource.T0", "Start time of current period [s]", 0, \
0.0,0.0,0.0,0,2688)
DeclareVariable("V2.signalSource.counter", "Period counter", 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("V2.signalSource.counter2", "", 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("R1.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,576)
DeclareAlias2("R1.i", "Current flowing from pin p to pin n [A]", "T1.B.i", 1, 5,\
 109, 0)
DeclareAlias2("R1.p.v", "Potential at the pin [V]", "V1.v", 1, 5, 11, 4)
DeclareAlias2("R1.p.i", "Current flowing into the pin [A]", "T1.B.i", 1, 5, 109,\
 132)
DeclareAlias2("R1.n.v", "Potential at the pin [V]", "T1.vbe", 1, 5, 91, 4)
DeclareAlias2("R1.n.i", "Current flowing into the pin [A]", "T1.B.i", -1, 5, 109,\
 132)
DeclareParameter("R1.R", "Resistance [Ohm]", 23, 1800, 0.0,0.0,0.0,0,560)
DeclareVariable("R1.useHeatPort", "true, if HeatPort enabled", false, 0.0,0.0,\
0.0,0,515)
DeclareParameter("R1.T", "fixed device Temperature if no HeatPort is enabled [K|degC]",\
 24, 293.15, 0.0,1E+100,0.0,0,560)
DeclareVariable("R1.LossPower", "[W]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R1.internalHeatPort.Q_flow", "External supported heat flow rate, to be computed via current balance; = heatPort.Q_flow [W]",\
 "R1.LossPower", -1, 5, 45, 1024)
DeclareAlias2("R1.internalHeatPort.T", "External Port temperature; = heatPort.T [K|degC]",\
 "R1.fixedTemperature.T", 1, 5, 46, 1024)
DeclareAlias2("R1.internalHeatPort.heatPort.T", "Port temperature [K|degC]", \
"R1.fixedTemperature.T", 1, 5, 46, 1028)
DeclareAlias2("R1.internalHeatPort.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "R1.LossPower", -1, 5, 45, 1156)
DeclareVariable("R1.fixedTemperature.T", "Fixed temperature at port [K|degC]", 0,\
 0.0,1E+100,0.0,0,2561)
DeclareAlias2("R1.fixedTemperature.port.T", "Port temperature [K|degC]", \
"R1.fixedTemperature.T", 1, 5, 46, 1028)
DeclareAlias2("R1.fixedTemperature.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "R1.LossPower", 1, 5, 45, 1156)
DeclareVariable("R2.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,576)
DeclareAlias2("R2.i", "Current flowing from pin p to pin n [A]", "T2.B.i", 1, 5,\
 138, 0)
DeclareAlias2("R2.p.v", "Potential at the pin [V]", "V2.v", 1, 5, 27, 4)
DeclareAlias2("R2.p.i", "Current flowing into the pin [A]", "T2.B.i", 1, 5, 138,\
 132)
DeclareAlias2("R2.n.v", "Potential at the pin [V]", "T2.vbe", 1, 5, 121, 4)
DeclareAlias2("R2.n.i", "Current flowing into the pin [A]", "T2.B.i", -1, 5, 138,\
 132)
DeclareParameter("R2.R", "Resistance [Ohm]", 25, 1800, 0.0,0.0,0.0,0,560)
DeclareVariable("R2.useHeatPort", "true, if HeatPort enabled", false, 0.0,0.0,\
0.0,0,515)
DeclareParameter("R2.T", "fixed device Temperature if no HeatPort is enabled [K|degC]",\
 26, 293.15, 0.0,1E+100,0.0,0,560)
DeclareVariable("R2.LossPower", "[W]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R2.internalHeatPort.Q_flow", "External supported heat flow rate, to be computed via current balance; = heatPort.Q_flow [W]",\
 "R2.LossPower", -1, 5, 49, 1024)
DeclareAlias2("R2.internalHeatPort.T", "External Port temperature; = heatPort.T [K|degC]",\
 "R2.fixedTemperature.T", 1, 5, 50, 1024)
DeclareAlias2("R2.internalHeatPort.heatPort.T", "Port temperature [K|degC]", \
"R2.fixedTemperature.T", 1, 5, 50, 1028)
DeclareAlias2("R2.internalHeatPort.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "R2.LossPower", -1, 5, 49, 1156)
DeclareVariable("R2.fixedTemperature.T", "Fixed temperature at port [K|degC]", 0,\
 0.0,1E+100,0.0,0,2561)
DeclareAlias2("R2.fixedTemperature.port.T", "Port temperature [K|degC]", \
"R2.fixedTemperature.T", 1, 5, 50, 1028)
DeclareAlias2("R2.fixedTemperature.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "R2.LossPower", 1, 5, 49, 1156)
DeclareVariable("RI.v", "Voltage drop between the two pins (= p.v - n.v) [V]", 0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("RI.i", "Current flowing from pin p to pin n [A]", 0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("RI.p.v", "Potential at the pin [V]", "T1.C.v", 1, 5, 107, 4)
DeclareAlias2("RI.p.i", "Current flowing into the pin [A]", "RI.i", 1, 5, 52, 132)
DeclareAlias2("RI.n.v", "Potential at the pin [V]", "V.v", 1, 5, 5, 4)
DeclareAlias2("RI.n.i", "Current flowing into the pin [A]", "RI.i", -1, 5, 52, 132)
DeclareParameter("RI.R", "Resistance [Ohm]", 27, 40, 0.0,0.0,0.0,0,560)
DeclareVariable("RI.useHeatPort", "true, if HeatPort enabled", false, 0.0,0.0,\
0.0,0,515)
DeclareParameter("RI.T", "fixed device Temperature if no HeatPort is enabled [K|degC]",\
 28, 293.15, 0.0,1E+100,0.0,0,560)
DeclareVariable("RI.LossPower", "[W]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("RI.internalHeatPort.Q_flow", "External supported heat flow rate, to be computed via current balance; = heatPort.Q_flow [W]",\
 "RI.LossPower", -1, 5, 54, 1024)
DeclareAlias2("RI.internalHeatPort.T", "External Port temperature; = heatPort.T [K|degC]",\
 "RI.fixedTemperature.T", 1, 5, 55, 1024)
DeclareAlias2("RI.internalHeatPort.heatPort.T", "Port temperature [K|degC]", \
"RI.fixedTemperature.T", 1, 5, 55, 1028)
DeclareAlias2("RI.internalHeatPort.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "RI.LossPower", -1, 5, 54, 1156)
DeclareVariable("RI.fixedTemperature.T", "Fixed temperature at port [K|degC]", 0,\
 0.0,1E+100,0.0,0,2561)
DeclareAlias2("RI.fixedTemperature.port.T", "Port temperature [K|degC]", \
"RI.fixedTemperature.T", 1, 5, 55, 1028)
DeclareAlias2("RI.fixedTemperature.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "RI.LossPower", 1, 5, 54, 1156)
DeclareVariable("Gnd.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("Gnd.p.i", "Current flowing into the pin [A]", "RI.i", 1, 5, 52, 132)
DeclareVariable("Gnd1.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("Gnd1.p.i", "Current flowing into the pin [A]", "T1.B.i", -1, 5, 109,\
 132)
DeclareVariable("Gnd2.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("Gnd2.p.i", "Current flowing into the pin [A]", "T2.B.i", -1, 5, 138,\
 132)
DeclareVariable("Gnd3.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("Gnd3.p.i", "Current flowing into the pin [A]", "T1.E.i", -1, 5, 111,\
 132)
DeclareVariable("Gnd4.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("Gnd4.p.i", "Current flowing into the pin [A]", "T2.E.i", -1, 5, 140,\
 132)
DeclareAlias2("C1.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
"T1.vbe", 1, 5, 91, 0)
DeclareVariable("C1.i", "Current flowing from pin p to pin n [A]", 0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("C1.p.v", "Potential at the pin [V]", "T1.vbe", 1, 5, 91, 4)
DeclareVariable("C1.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C1.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("C1.n.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C1.C", "Capacitance [F]", 0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("C2.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
"T1.C.v", 1, 5, 107, 0)
DeclareVariable("C2.i", "Current flowing from pin p to pin n [A]", 0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("C2.p.v", "Potential at the pin [V]", "T1.C.v", 1, 5, 107, 4)
DeclareVariable("C2.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C2.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("C2.n.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C2.C", "Capacitance [F]", 0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("C3.v", "Voltage drop between the two pins (= p.v - n.v) [V]", \
"T2.vbe", 1, 5, 121, 0)
DeclareVariable("C3.i", "Current flowing from pin p to pin n [A]", 0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("C3.p.v", "Potential at the pin [V]", "T2.vbe", 1, 5, 121, 4)
DeclareVariable("C3.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C3.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("C3.n.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("C3.C", "Capacitance [F]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("Gnd5.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("Gnd5.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("Gnd6.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("Gnd6.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("Gnd7.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("Gnd7.p.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareParameter("T1.Bf", "Forward beta", 29, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("T1.Br", "Reverse beta", 30, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("T1.Is", "Transport saturation current [A]", 31, 1E-014, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.Vak", "Early voltage (inverse), 1/Volt [1/V]", 32, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("T1.Tauf", "Ideal forward transit time [s]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.Taur", "Ideal reverse transit time [s]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.Ccs", "Collector-substrat(ground) cap. [F]", 0, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("T1.Cje", "Base-emitter zero bias depletion cap. [F]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("T1.Cjc", "Base-coll. zero bias depletion cap. [F]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareParameter("T1.Phie", "Base-emitter diffusion voltage [V]", 33, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.Me", "Base-emitter gradation exponent", 34, 0.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T1.Phic", "Base-collector diffusion voltage [V]", 35, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.Mc", "Base-collector gradation exponent", 36, 0.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T1.Gbc", "Base-collector conductance [S]", 37, 1E-012, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.Gbe", "Base-emitter conductance [S]", 38, 1E-012, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T1.EMin", "if x < EMin, the exp(x) function is linearized", 39,\
 (-100), 0.0,0.0,0.0,0,560)
DeclareParameter("T1.EMax", "if x > EMax, the exp(x) function is linearized", 40,\
 40, 0.0,0.0,0.0,0,560)
DeclareParameter("T1.Tnom", "Parameter measurement temperature [K|degC]", 41, \
300.15, 0.0,1E+100,0.0,0,560)
DeclareParameter("T1.XTI", "Temperature exponent for effect on Is", 42, 3, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.XTB", "Forward and reverse beta temperature exponent", 43, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("T1.EG", "Energy gap for temperature effect on Is", 44, 1.11, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.NF", "Forward current emission coefficient", 45, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.NR", "Reverse current emission coefficient", 46, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T1.K", "Boltzmann's constant", 47, 1.3806226E-023, 0.0,0.0,0.0,\
0,560)
DeclareParameter("T1.q", "Elementary electronic charge", 48, 1.6021918E-019, \
0.0,0.0,0.0,0,560)
DeclareVariable("T1.useHeatPort", "true, if HeatPort enabled", true, 0.0,0.0,0.0,\
0,515)
DeclareAlias2("T1.heatPort.T", "Port temperature [K|degC]", "T1.internalHeatPort.T", 1,\
 5, 89, 4)
DeclareAlias2("T1.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T1.LossPower", -1, 5, 88, 132)
DeclareVariable("T1.LossPower", "[W]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("T1.internalHeatPort.Q_flow", "External supported heat flow rate, to be computed via current balance; = heatPort.Q_flow [W]",\
 "T1.LossPower", -1, 5, 88, 1024)
DeclareVariable("T1.internalHeatPort.T", "External Port temperature; = heatPort.T [K|degC]",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareAlias2("T1.internalHeatPort.heatPort.T", "Port temperature [K|degC]", \
"T1.internalHeatPort.T", 1, 5, 89, 1028)
DeclareAlias2("T1.internalHeatPort.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T1.LossPower", -1, 5, 88, 1156)
DeclareVariable("T1.vbc", "[V]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.vbe", "[V]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.qbk", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.ibc", "[A]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.ibe", "[A]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.cbc", "[F]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.cbe", "[F]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.ExMin", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.ExMax", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.Capcje", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.Capcjc", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T1.is_t", "", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.br_t", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.bf_t", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.vt_t", "", 0.01, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.hexp", "", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.htempexp", "", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T1.C.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,520)
DeclareVariable("T1.C.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("T1.B.v", "Potential at the pin [V]", "T1.vbe", 1, 5, 91, 4)
DeclareVariable("T1.B.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
DeclareVariable("T1.E.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("T1.E.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
DeclareParameter("T2.Bf", "Forward beta", 49, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("T2.Br", "Reverse beta", 50, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("T2.Is", "Transport saturation current [A]", 51, 1E-014, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.Vak", "Early voltage (inverse), 1/Volt [1/V]", 52, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("T2.Tauf", "Ideal forward transit time [s]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.Taur", "Ideal reverse transit time [s]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.Ccs", "Collector-substrat(ground) cap. [F]", 0, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("T2.Cje", "Base-emitter zero bias depletion cap. [F]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("T2.Cjc", "Base-coll. zero bias depletion cap. [F]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareParameter("T2.Phie", "Base-emitter diffusion voltage [V]", 53, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.Me", "Base-emitter gradation exponent", 54, 0.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T2.Phic", "Base-collector diffusion voltage [V]", 55, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.Mc", "Base-collector gradation exponent", 56, 0.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T2.Gbc", "Base-collector conductance [S]", 57, 1E-012, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.Gbe", "Base-emitter conductance [S]", 58, 1E-012, 0.0,0.0,\
0.0,0,560)
DeclareParameter("T2.EMin", "if x < EMin, the exp(x) function is linearized", 59,\
 (-100), 0.0,0.0,0.0,0,560)
DeclareParameter("T2.EMax", "if x > EMax, the exp(x) function is linearized", 60,\
 40, 0.0,0.0,0.0,0,560)
DeclareParameter("T2.Tnom", "Parameter measurement temperature [K|degC]", 61, \
300.15, 0.0,1E+100,0.0,0,560)
DeclareParameter("T2.XTI", "Temperature exponent for effect on Is", 62, 3, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.XTB", "Forward and reverse beta temperature exponent", 63, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("T2.EG", "Energy gap for temperature effect on Is", 64, 1.11, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.NF", "Forward current emission coefficient", 65, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.NR", "Reverse current emission coefficient", 66, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("T2.K", "Boltzmann's constant", 67, 1.3806226E-023, 0.0,0.0,0.0,\
0,560)
DeclareParameter("T2.q", "Elementary electronic charge", 68, 1.6021918E-019, \
0.0,0.0,0.0,0,560)
DeclareVariable("T2.useHeatPort", "true, if HeatPort enabled", true, 0.0,0.0,0.0,\
0,515)
DeclareAlias2("T2.heatPort.T", "Port temperature [K|degC]", "T2.internalHeatPort.T", 1,\
 5, 119, 4)
DeclareAlias2("T2.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T2.LossPower", -1, 5, 118, 132)
DeclareVariable("T2.LossPower", "[W]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("T2.internalHeatPort.Q_flow", "External supported heat flow rate, to be computed via current balance; = heatPort.Q_flow [W]",\
 "T2.LossPower", -1, 5, 118, 1024)
DeclareVariable("T2.internalHeatPort.T", "External Port temperature; = heatPort.T [K|degC]",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareAlias2("T2.internalHeatPort.heatPort.T", "Port temperature [K|degC]", \
"T2.internalHeatPort.T", 1, 5, 119, 1028)
DeclareAlias2("T2.internalHeatPort.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "T2.LossPower", -1, 5, 118, 1156)
DeclareVariable("T2.vbc", "[V]", 0, 0.0,0.0,0.0,0,576)
DeclareVariable("T2.vbe", "[V]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.qbk", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.ibc", "[A]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.ibe", "[A]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.cbc", "[F]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.cbe", "[F]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.ExMin", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.ExMax", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.Capcje", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.Capcjc", "", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("T2.is_t", "", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.br_t", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.bf_t", "[1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.vt_t", "", 0.01, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.hexp", "", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("T2.htempexp", "", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("T2.C.v", "Potential at the pin [V]", "T1.C.v", 1, 5, 107, 4)
DeclareVariable("T2.C.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("T2.B.v", "Potential at the pin [V]", "T2.vbe", 1, 5, 121, 4)
DeclareVariable("T2.B.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
DeclareVariable("T2.E.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("T2.E.i", "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,776)
EndNonAlias(0)
#define NX_    1
#define NX2_   5
#define NU_    0
#define NY_    0
#define NW_    141
#define NP_    69
#define NPS_   0
#define NHash1_ -1459636880
#define NHash2_ 175493250
#define NHash3_ 0
#define NI_    0
#define NRelF_ 14
#define NRel_  14
#define NTim_  10
#define NSamp_ 2
#define NCons_ 0
#define NA_    83
#define SizePre_ 4
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 6
#define NrDymolaTimers_ 0
#define NWhen_ 6
#define NCheckIf_ 0
#define NGlobalHelp_ 128
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#include <dsblock5.c>

StartDataBlock
StartPreBlock
preW(W_[25],"V1.signalSource.counter", W_[18], 1);
pre(W_[26],"V1.signalSource.counter2", W_[18], 0);
preW(W_[41],"V2.signalSource.counter", W_[34], 3);
pre(W_[42],"V2.signalSource.counter2", W_[34], 2);
EndPreBlock
StartEqBlock
DoRemember_(W_[43], 0, 3);
DoRemember_(W_[47], 0, 2);
DoRemember_(W_[120], 0, 0);
DoRemember_(W_[3], 0, 4);
DoRemember_(W_[4], 0, 1);
DoRemember_(F_[0], 0, 5);
EndEqBlock
UpdateQEvaluate(6)
UpdateSampleCounters(2)
EndDataBlock
