<HTML>
<HEAD>
<TITLE>Modelica.Math.Matrices.Utilities</TITLE>
<META name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META name="description" content="&quot;Utility functions that should not be directly utilized by the user&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P></P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Utilities<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Math.Matrices.Utilities"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.Utilities</H2>
<B>Utility functions that should not be directly utilized by the user</B>
<P></P>
<P></P><H3>Information</H3>
<PRE></pre>
<p>
This package contains utility functions that are utilized by higher level matrix functions.
These functions are usually not useful for an end-user.
</p>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons_UtilitiesPackage.html#Modelica.Icons.UtilitiesPackage"
>Modelica.Icons.UtilitiesPackage</A> (Icon for utility packages).
<P></P><H3>Package Content</H3>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>continuousRiccatiIterative</A>
</TD><TD>Newton&#39;s method with exact line search for iterative solving continuous algebraic Riccati equation</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>discreteRiccatiIterative</A>
</TD><TD>Newton&#39;s method with exact line search for solving discrete algebraic Riccati equation</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.householderReflection" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderReflection"
>householderReflection</A>
</TD><TD>Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"
>householderSimilarityTransformation</A>
</TD><TD>Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.toUpperHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.toUpperHessenberg"
>toUpperHessenberg</A>
</TD><TD>Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q&#39; * A * Q = H</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg"
>eigenvaluesHessenberg</A>
</TD><TD>Compute eigenvalues of an upper Hessenberg form matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.reorderRSF" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.reorderRSF"
>reorderRSF</A>
</TD><TD>Reorders a real Schur form to clusters of stable and unstable eigenvalues</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.Ex317ffc06aa9e2e4ftionsS.png" ALT="Modelica.Math.Matrices.Utilities.findLocal_tk" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.findLocal_tk"
>findLocal_tk</A>
</TD><TD>Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE continuousRiccatiIterative<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.continuousRiccatiIterative</H2>
<B>Newton&#39;s method with exact line search for iterative solving continuous algebraic Riccati equation</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<b>continuousRiccatiIterative</b>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<b>continuousRiccatiIterative</b>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving continuous algebraic Riccati equations (care). It utilizes Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means means, that at each iteration <code>i</code> a Newton step <code><b>delta</b>_i</code>
</p>
<blockquote><pre>
  <b>X</b>_i+1 = <b>X</b>_i + <b>delta</b>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
    r = || <b>X</b>_i+1*<b>A</b> +<b>A</b>'*<b>X</b>_i+1 - <b>X</b>_i+1*<b>G</b>*<b>X</b>_i+1 + <b>Q</b> ||.
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
        -1
  G = <b>B</b>*<b>R</b> *<b>B</b>'
</pre></blockquote>
<p>

The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <b>delta</b>_i/<b>X</b>_i became smaller than eps.
<p>

With an appropriate initial value <b>X</b>0 a sufficiently accurate solution might be reach within a few iteration steps. Although a Lyapunov equation
of order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>Matrices.continuousRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.<br>

The algorithm is taken from [1] and [2].

<h4>References</h4>
<PRE>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</PRE>

<h4>Example</h4>
<blockquote><pre>
     A=[0.0,         1.0,         0.0,         0.0;
        0.0,        -1.890,       3.900e-01,  -5.530;
        0.0,        -3.400e-02,  -2.980,       2.430;
        3.400e-02,  -1.100e-03,  -9.900e-01,  -2.100e-01];

     B=[ 0.0,         0.0;
         3.600e-01,  -1.60;
        -9.500e-01,  -3.200e-02;
         3.000e-02,   0.0];

     R=[1, 0; 0, 1];

     Q=[2.313,       2.727,       6.880e-01,   2.300e-02;
        2.727,       4.271,       1.148,       3.230e-01;
        6.880e-01,   1.148,       3.130e-01,   1.020e-01;
        2.300e-02,   3.230e-01,   1.020e-01,   8.300e-02];

    X0=identity(4);

    (X,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0);

  //  X = [1.3239,  0.9015,  0.5466, -1.7672;
           0.9015,  0.9607,  0.4334, -1.1989;
           0.5466,  0.4334,  0.4605, -1.3633;
          -1.7672, -1.1989, -1.3633,  4.4612]
  // r =  2.48809423389491E-015

    (,r) = Matrices.Utilities.continuousRiccatiIterative(A, B, R, Q, X0,4);

   // r =  0.0004;

<br>
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>Matrices.Utilities.discreteRiccatiIterative</a><br>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>Matrices.continuousRiccati</a>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B in G = B*inv(R)*B&#39;</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>Matrix R in G = B*inv(R)*B&#39;</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Matrix Q of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</TD></TR>
<TR><TD>X0[size(A, 1), size(A, 2)]</TD><TD>Initial approximate solution for X*A + A&#39;*X -X*G*X +Q = 0</TD></TR>
<TR><TD>maxSteps</TD><TD>Maximal number of iteration steps</TD></TR>
<TR><TD>eps</TD><TD>Tolerance for stop criterion</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(X0, 1), size(X0, 2)]</TD><TD>Solution X of Riccati equation X*A + A&#39;*X -X*G*X +Q = 0</TD></TR>
<TR><TD>r</TD><TD>Norm of X*A + A&#39;*X - X*G*X + Q, zero for exact solution</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE discreteRiccatiIterative<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.discreteRiccatiIterative</H2>
<B>Newton&#39;s method with exact line search for solving discrete algebraic Riccati equation</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           X = Matrices.Utilities.<b>discreteRiccatiIterative</b>(A, B, R, Q, X0);
      (X, r) = Matrices.Utilities.<b>discreteRiccatiIterative</b>(A, B, R, Q, X0, maxSteps, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
This function provides a Newton-like method for solving discrete-time algebraic Riccati equations. It uses Exact Line Search to improve the sometimes erratic
convergence of Newton's method. Exact line search in this case means means, that at each iteration <code>i</code> a Newton step <code><b>delta</b>_i</code>
</p>
<blockquote><pre>
  <b>X</b>_i+1 = <b>X</b>_i + <b>delta</b>_i
</pre></blockquote>
<p>
is taken in the direction to minimize the Frobenius norm of the residual
</p>
<blockquote><pre>
  r = || <b>A</b>'<b>X</b>_i+1*<b>A</b> - <b>X</b>_i+1 - <b>A</b>'<b>X</b>_i+1*<b>G</b>_i*<b>X</b>_i+1*<b>A</b> + <b>Q</b> ||
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
                       -1
  G_i = <b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>_i*<b>B</b>) *<b>B</b>'
</pre></blockquote>
<p>

Output <code>r</code> is the norm of the residual of the last iteration.<br>
<p>
The inputs "maxSteps" and "eps" specify the termination of the iteration. The iteration is terminated if either
maxSteps iteration steps have been performed or the relative change <b>delta</b>_i/<b>X</b>_i became smaller than eps.
<p>

With an appropriate initial value <b>X</b>0 a sufficiently accurate solution might be reach with a few iteration steps. Although a Lyapunov equation of
order <code>n</code> (n is the order of the Riccati equation) is to be solved at each iteration step, the algorithm might be faster
than a direct method like <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>Matrices.discreteRiccati</a>, since direct methods have to solve the 2*n-order Hamiltonian
system equation.

The algorithm is taken from [1] and [2].

<h4>References</h4>
<PRE>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
  [2] Datta, B.N.
      Numerical Methods for Linear Control Systems
      Elsevier Academic Press, 2004.
</PRE>

<h4>Example</h4>
<blockquote><pre>
     A  = [0.9970,    0.0000,    0.0000,    0.0000;
           1.0000,    0.0000,    0.0000,    0.0000;
           0.0000,    1.0000,    0.0000,    0.0000;
           0.0000,    0.0000,    1.0000,    0.0000];

     B  = [0.0150;
           0.0000;
           0.0000;
           0.0000];

     R = [0.2500];

     Q = [0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 0;
          0, 0, 0, 1];

    X0=identity(4);

    (X,r) = Matrices.Utilities.discreteRiccatiIterative(A, B, R, Q, X0);

  //  X = [30.625, 0.0, 0.0, 0.0;
            0.0,   1.0, 0.0, 0.0;
            0.0,   0.0, 1.0, 0.0;
            0.0,   0.0, 0.0, 1.0];

  // r =   3.10862446895044E-015
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>Matrices.Utilities.continuousRiccatiIterative</a><br>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>Matrices.discreteRiccati</a>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of discrete Riccati equation</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B of discrete Riccati equation</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>Matrix R of discrete Riccati equation</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Matrix Q of discrete Riccati equation</TD></TR>
<TR><TD>X0[size(A, 1), size(A, 2)]</TD><TD>Initial approximate solution discrete Riccati equation</TD></TR>
<TR><TD>maxSteps</TD><TD>Maximal number of iteration steps</TD></TR>
<TR><TD>eps</TD><TD>Tolerance for stop criterion</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(X0, 1), size(X0, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>r</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderReflection<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.householderReflection" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.householderReflection"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.householderReflection</H2>
<B>Reflect each of the vectors a_i of matrix  A=[a_1, a_2, ..., a_n] on a plane with orthogonal vector u</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderReflection</b>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder reflection (transformation)
</p>
<blockquote>
 <b>Ar</b> = <b>Q</b>*<b>A</b>
</blockquote>
with
<blockquote>
 <b>Q</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>)
</blockquote>
<p>
where <b>u</b> is Householder vector, i.e., the normal vector of the reflection plane.
<p>
Householder reflection is widely used in numerical linear algebra, e.g., to perform QR decompositions.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];

  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u= {0.763, 0.646, 0}

  Ar=householderReflection(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"
>Matrices.Utilities.housholderSimilarityTransformation</a>,<br>
<A HREF="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderReflection"
>Vectors.Utilities.householderReflection</a>,<br>
<A HREF="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderVector"
>Vectors.Utilities.householderVector</a>
</p>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>RA[size(A, 1), size(A, 2)]</TD><TD>Reflexion of A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderSimilarityTransformation<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.householderSimilarityTransformation"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.householderSimilarityTransformation</H2>
<B>Perform the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
  As = Matrices.<b>householderSimilarityTransformation</b>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Householder similarity transformation
</p>
<blockquote>
 <b>As</b> = <b>S</b>*<b>A</b>*<b>S</b>
</blockquote>
with
<blockquote>
 <b>S</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};

  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}

  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.householderReflection"
>Matrices.Utilities.householderReflection</a>,<br>
<A HREF="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderReflection"
>Vectors.Utilities.householderReflection</a>,<br>
<A HREF="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities.householderVector"
>Vectors.Utilities.householderVector</a>
</p>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>SAS[size(A, 1), size(A, 1)]</TD><TD>Transformation of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE toUpperHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.toUpperHessenberg" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.toUpperHessenberg"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.toUpperHessenberg</H2>
<B>Transform a real square matrix A to upper Hessenberg form H by orthogonal similarity transformation:  Q&#39; * A * Q = H</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
   <h4>Syntax</h4>
<blockquote><pre>
         H = Matrices.Utilities.<b>toUpperHessenberg</b>(A);
         (H, V, tau, info) = Matrices.Utilities.<b>toUpperHessenberg</b>(A,ilo, ihi);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>toUpperHessenberg</b> computes a upper Hessenberg form <b>H</b> of a matrix <b>A</b> by orthogonal similarity transformation:  <b>Q</b>' * <b>A</b> * <b>Q</b> = <b>H</b>.
With the optional inputs ilo and ihi, also partial transformation is possible. The function calls LAPACK function DGEHRD.
See <A HREF="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgehrd"
>Matrices.LAPACK.dgehrd</a> for more information about the additional outputs V, tau, info and inputs ilo, ihi.
</p>

<h4>Example</h4>
<blockquote><pre>
 A  = [1, 2, 3;
       6, 5, 4;
       1, 0, 0];

 H = toUpperHessenberg(A);

  results in:

 H = [1.0,  -2.466,  2.630;
     -6.083, 5.514, -3.081;
      0.0,   0.919, -0.514]

</pre></blockquote>

<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg"
>Matrices.hessenberg</a>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>ilo</TD><TD>Lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>ihi</TD><TD>Highest index where the original matrix had been Hessenbergform</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Upper Hessenberg form</TD></TR>
<TR><TD>V[size(A, 1), size(A, 2)]</TD><TD>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</TD></TR>
<TR><TD>tau[max(0, size(A, 1) - 1)]</TD><TD>Scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>Information of successful function call</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenvaluesHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.eigenvaluesHessenberg"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.eigenvaluesHessenberg</H2>
<B>Compute eigenvalues of an upper Hessenberg form matrix</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           ev = Matrices.Utilities.<b>eigenvaluesHessenberg</b>(H);
   (ev, info) = Matrices.Utilities.<b>eigenvaluesHessenberg</b>(H);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the eigenvalues of a Hessenberg form matrix. Transformation to Hessenberg form is the first step in eigenvalue computation for arbitrary matrices with QR decomposition.
This step can be skipped if the matrix has already Hessenberg form.
</p>

<p>
The function uses the LAPACK-routine dhseqr. Output <code>info</code> is 0 for a successful call of this
function.<br>
See <A HREF="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhseqr"
>Matrices.LAPACK.dhseqr</a> for details
</p>

<h4>Example</h4>
<blockquote><pre>
     Real A[3,3] = [1,2,3;
                    9,8,7;
                    0,1,0];

     Real ev[3,2];

     ev := Matrices.Utilities.eigenvaluesHessenberg(A);

  // ev  = [10.7538,    0.0;
            -0.8769,    1.0444;
            -0.8769,   -1.0444]
  // = {10.7538,  -0.8769 +- i*1.0444}
</pre></blockquote>
<br>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg"
>Matrices.hessenberg</a>
</p>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[:, size(H, 1)]</TD><TD>Hessenberg matrix H</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>ev[size(H, 1), 2]</TD><TD>Eigenvalues</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reorderRSF<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.reorderRSF" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.reorderRSF"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.reorderRSF</H2>
<B>Reorders a real Schur form to clusters of stable and unstable eigenvalues</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
              To = Matrices.Utilities.<b>reorderRSF</b>(T, Q, alphaReal, alphaImag);
(To, Qo, wr, wi) = Matrices.Utilities.<b>reorderRSF</b>(T, Q, alphaReal, alphaImag, iscontinuous);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>reorderRSF</b>() reorders a real Schur form such that the stable eigenvalues of
the system are in the 1-by-1 and 2-by-2 diagonal blocks of the block <b>upper</b> triangular matrix.
If the Schur form is referenced to a continuous system the staple eigenvalues are in the left complex half plane.
The stable eigenvalues of a discrete system are inside the complex unit circle.<br>
This function is used for example to solve algebraic Riccati equations
(<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati"
>continuousRiccati</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati"
>discreteRiccati</a>). In this context the Schur form
as well as the corresponding eigenvalues and the transformation matrix <b>Q</b> are known, why the eigenvalues and the transformation matrix are inputs to <b>reorderRSF()</b>.<br>

The Schur vector matrix <b>Qo</b> is also reordered according to <b>To</b>. The vectors <b>wr</b> and <b>wi</b> contains the real and imaginary parts of the
reordered eigenvalues respectively.
</p>

<h4>Example</h4>
<blockquote><pre>
  T := [-1,2, 3,4;
         0,2, 6,5;
         0,0,-3,5;
         0,0, 0,6];
  To := Matrices.Utilities.reorderRSF(T,identity(4),{-1, 2, -3, 6},{0, 0, 0, 0}, true);

  // To = [-1.0, -0.384, 3.585, 4.0;
  //        0.0, -3.0,   6.0,   0.64;
  //        0.0,  0.0,   2.0,   7.04;
  //        0.0,  0.0,   0.0,   6.0]
</pre></blockquote>
<p>
See also <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.realSchur"
>Matrices.realSchur</a>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>T[:, :]</TD><TD>Real Schur form</TD></TR>
<TR><TD>Q[:, size(T, 2)]</TD><TD>Schur vector Matrix</TD></TR>
<TR><TD>alphaReal[size(T, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>alphaImag[size(T, 1)]</TD><TD>Imaginary part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>iscontinuous</TD><TD>True if the according system is continuous. False for discrete systems</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>To[size(T, 1), size(T, 2)]</TD><TD>Reordered Schur form</TD></TR>
<TR><TD>Qo[size(T, 1), size(T, 2)]</TD><TD>Reordered Schur vector matrix</TD></TR>
<TR><TD>wr[size(T, 2)]</TD><TD>Reordered eigenvalues, real part</TD></TR>
<TR><TD>wi[size(T, 2)]</TD><TD>Reordered eigenvalues, imaginary part</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE findLocal_tk<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.Ut613baac73b7af2dcativeI.png" ALT="Modelica.Math.Matrices.Utilities.findLocal_tk" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.Utilities.findLocal_tk"></A><A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities"
>Modelica.Math.Matrices.Utilities</A>.findLocal_tk</H2>
<B>Find a local minimizer tk to define the length of the step tk*Nk in continuousRiccatiIterative and discreteRiccatiIterative</B><p></P>
<P></P><H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           tk = Matrices.Utilities.<b>findLocal_tk</b>(Rk, Vk);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <code>findLocal_tk()</code> is an auxiliary function called in iterative solver for algebraic Riccati equation based on Newton's method with
exact line search like <A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>continuousRiccatiIterative</a><br>
and <A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>discreteRiccatiIterative</a>.<br>
The function computes the local minimum of the function f_k(t_k)
</p>
<blockquote><pre>
  f_k(t_k) = alpha_k*(1-t_k)^2 + 2*beta_k*(1-t)*t^2 + gamma_k*t^4
</pre></blockquote>
<p>
by calculating the zeros of the derivation d f_k/d t_k. It is known that the function f_k(t_k) has a local minimum at some value t_k_min in [0, 2].<br>
With t_k_min the norm of the next residual of the algorithm will be minimized.<br>
See [1] for more information

<h4>References</h4>
<PRE>
  [1] Benner, P., Byers, R.
      An Exact Line Search Method for Solving Generalized Continuous-Time Algebraic Riccati Equations
      IEEE Transactions On Automatic Control, Vol. 43, No. 1, pp. 101-107, 1998.
</PRE>

<h4>See also</h4>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative"
>Matrices.Utilities.continuousRiccatiIterative</a><br>
<A HREF="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.discreteRiccatiIterative"
>Matrices.Utilities.discreteRiccatiIterative</a><br>
<pre></PRE><P></P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Rk[:, size(Rk, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Vk[size(Rk, 1), size(Rk, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>tk</TD><TD>&nbsp;</TD></TR>
</TABLE>
<address><a href="http://www.3ds.com/">Automatically generated</a> Mon Sep 23 17:21:10 2013.
</address></BODY>
</HTML>
